Index: nspluginwrapper-1.2.2/src/npw-remote-agent-info.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ nspluginwrapper-1.2.2/src/npw-remote-agent-info.c	2010-09-09 21:54:10.000000000 +0200
@@ -0,0 +1,647 @@
+/*
+ * npw-remote-agent-info.c
+ *
+ * We need to use libcurl to fetch a URL for the plugin, because
+ * the initialization of the RPC channel is before the plugin is initialized
+ * and we don't have the NPP instance for NPP_GetURL (or similar funcs)
+ *
+ * Description:
+ *
+ * If NPW_USE_TCPIP is defined then we use TCP sockets instead of UNIX sockets
+ *
+ * If NPW_REMOTE_AGENT_URI is defined
+ *
+ *
+ * Note: Problem in compiling npw-remote-agent-info as 64bits... in 32bit
+ *
+ * 21/8/2010 - Nito@Qindel.ES
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include "sysdeps.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <curl/curl.h>
+#include <curl/types.h>
+#include <curl/easy.h>
+#include <X11/Xlib.h>
+#include "npw-use-tcp-sockets.h"
+#include "npw-remote-agent-info.h"
+
+#define DEBUG 1
+#include "debug.h"
+
+//#define MYURL "http://localhost/port"
+#define USERAGENT "QVDnswrapper/1.0"
+#define MAXKEYS 128
+#define MAX_KEY_SIZE 128
+#define MAX_VALUE_SIZE 128
+#define MAX_URL_SIZE 1024
+struct MemoryStruct {
+  char *memory;
+  size_t size;
+};
+
+
+static int rpc_port = 0;
+char rpc_host[MAX_URL_SIZE];
+char *npw_agent_uri = NULL;
+char *npw_xwin_translate_service_uri = NULL;
+
+
+
+/******************************************************************************
+ * This is a replacement for strsep which is not portable (missing on
+ Solaris).
+ */
+ static char* getToken(char** str, const char* delims)
+ {
+     char* token;
+
+     if (*str==NULL) {
+         /* No more tokens */
+         return NULL;
+     }
+
+     token=*str;
+     while (**str!='\0') {
+         if (strchr(delims,**str)!=NULL) {
+             **str='\0';
+             (*str)++;
+             return token;
+         }
+         (*str)++;
+     }
+     /* There is no other token */
+     *str=NULL;
+     return token;
+ }
+
+
+static void *myrealloc(void *ptr, size_t size)
+{
+  /* There might be a realloc() out there that doesn't like reallocing
+     NULL pointers, so we take care of it here */
+  if(ptr)
+      return realloc(ptr, size);
+  else
+      return malloc(size);
+}
+
+
+static size_t
+WriteMemoryCallback(void *ptr, size_t size, size_t nmemb, void *data)
+{
+  size_t realsize = size * nmemb;
+  struct MemoryStruct *mem = (struct MemoryStruct *)data;
+
+  mem->memory = myrealloc(mem->memory, mem->size + realsize + 1);
+  if (mem->memory) {
+    memcpy(&(mem->memory[mem->size]), ptr, realsize);
+    mem->size += realsize;
+    mem->memory[mem->size] = 0;
+  }
+  return realsize;
+}
+
+void init_array(char **array) {
+  memset(array, 0, MAXKEYS * sizeof(char *));
+}
+
+void free_array(char **array) {
+  int i;
+  char **ptr;
+  ptr=array;
+  for (i = 0; i < MAXKEYS; ++i) {
+    if (*ptr) {
+      free(*ptr);
+      *ptr=NULL;
+    }
+    ++ ptr;
+  }
+}
+
+void assign(char **ptr, const char *value) {
+  int len;
+  len = strlen(value);
+  *ptr = malloc(len + 1);
+  strncpy(*ptr, value, len+1);
+}
+
+//Duplicate entries ocupy space, but only the first is used
+int parse_page(struct MemoryStruct *chunk, char **keys, char **values) {
+  char *line, *copy, **copy_ptr, *copy_free_ptr, format[32],
+    key[MAX_KEY_SIZE + 1], value[MAX_VALUE_SIZE + 1];
+  int parsed_elements, keys_parsed;
+
+  D(bug("parse_page: start\n"));
+  // Format string to parse chars
+  sprintf(format, " %%%d[^= ] = %%%d[^#] ", MAX_KEY_SIZE, MAX_VALUE_SIZE);
+
+  // Set end of string for long keys and values
+  key[MAX_KEY_SIZE] = 0;
+  value[MAX_VALUE_SIZE] = 0 ;
+
+  // Copy the buffer to be parsed
+  copy_free_ptr = copy = malloc(chunk->size);
+  memcpy(copy, chunk->memory, chunk->size);
+  copy_ptr = &copy;
+
+
+  // Parse line by line
+  line = getToken(copy_ptr, "\n");
+  for (keys_parsed=0; *copy_ptr != NULL; line = getToken(copy_ptr, "\n")) {
+    D(bug("parse_page: line %s\n", line));
+    if (line == NULL)       // Should never happen
+      break;
+
+    if (keys_parsed >= MAXKEYS) {
+      	npw_printf("ERROR: Too many keys in the file. Skipping the rest\n");
+      break;
+    }
+
+    if (strlen(line) == 0)
+      continue;
+
+    if (line[0] == '#')
+      continue;
+
+    if ((parsed_elements = sscanf(line, format, key, value)) < 2) {
+	npw_printf("ERROR: line <%s> not recognized key=%s, value=%s, int=%d\n", line, key, value, parsed_elements);
+      continue;
+    }
+
+    D(bug("parse_page: key %s value %s\n", key, value));
+    assign(keys, key);
+    keys ++;
+    assign(values, value);
+    values ++;
+    keys_parsed ++;
+  }
+  free(copy_free_ptr);
+  return 0;
+}
+
+// Not defined and empty is the same
+const char * getvalue(char **keys, char**values, const char *key) {
+  int i;
+  for(i=0; i < MAXKEYS; i++) {
+    if ((*keys == NULL) || (*values == NULL)) {
+      break;
+    }
+    if (!strcmp(key, *keys)){
+      return *values;
+    }
+    keys ++;
+    values ++;
+  }
+  return "";
+}
+
+
+int fetch_remote_agent_url(const char *myurl, struct MemoryStruct *chunk) {
+  CURL *handle;
+  CURLcode res;
+  char error_buffer[CURL_ERROR_SIZE];
+
+
+
+  if (curl_global_init(CURL_GLOBAL_ALL)) {
+    npw_printf("Error intializing curl for url %s", myurl);
+    return -1;
+  }
+
+  handle = curl_easy_init();
+  curl_easy_setopt(handle, CURLOPT_URL, myurl);
+  curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
+  curl_easy_setopt(handle, CURLOPT_WRITEDATA, (void *)chunk);
+  curl_easy_setopt(handle, CURLOPT_USERAGENT, USERAGENT);
+  curl_easy_setopt(handle, CURLOPT_ERRORBUFFER, error_buffer);
+  res = curl_easy_perform(handle);
+  if (res) {
+    npw_printf("Error getting URL %s: %s", myurl, error_buffer);
+  }
+  curl_easy_cleanup(handle);
+  curl_global_cleanup();
+  return res;
+}
+
+
+
+int return_rpc_port() {
+  return rpc_port++;
+}
+
+int set_tcp_ip_and_remote_invocation_flags() {
+  //  int use_tcp = 0;
+  // If NPW_USE_TCPIP_PORT or NPW_REMOTE_AGENT_ENV is defined then use tcp_sockets
+  const char *npw_tcp_port = getenv(NPW_USE_TCPIP_PORT);
+  if (npw_tcp_port)
+    {
+      set_tcp_sockets();
+      rpc_port = atoi(npw_tcp_port);
+      if (rpc_port >= 1024 && rpc_port <= 65535)
+	{
+	  D(bug("%s defined: %d. Using tcp sockets\n", NPW_USE_TCPIP_PORT, rpc_port));
+	}
+      else
+	{
+	  D(bug("%s defined: %s. But the socket is < 1024 or > 65535. Setting default %d\n", NPW_USE_TCPIP_PORT, npw_tcp_port, rpc_port));
+	  rpc_port = NPW_RPC_DEFAULT_PORT;
+	}
+    }
+  npw_agent_uri = getenv(NPW_REMOTE_AGENT_ENV);
+  if (npw_agent_uri)
+    {
+      set_tcp_sockets();
+      set_remote_invocation();
+      D(bug("verify_if_using_tcp_sockets %s defined: %s. Using tcp sockets\n", NPW_REMOTE_AGENT_ENV, npw_agent_uri));
+    }
+  else
+    {
+      D(bug("verify_if_using_tcp_sockets checking for http url %s not defined\n", NPW_REMOTE_AGENT_ENV));
+    }
+  return use_tcp_sockets();
+}
+
+void dump_keys(char **keys, char **values) {
+  int i;
+
+  for (i=0; (i<MAXKEYS && *keys != NULL && *values != NULL); ++i) {
+    D(bug("dump_keys: key %d, %s, %s\n", i, *keys, *values));
+    keys ++;
+    values ++;
+  }
+
+}
+
+void init_mem(char **keys, char **values,   struct MemoryStruct *chunk) {
+  init_array(keys);
+  init_array(values);
+  chunk->memory=NULL;
+  chunk->size=0;
+}
+
+void free_mem(char **keys, char **values,   struct MemoryStruct *chunk) {
+  free_array(keys);
+  free_array(values);
+  if (chunk->memory)
+    free(chunk->memory);
+  chunk->size=0;
+}
+
+void build_url(char *myurl, int size, const char *baseurl, const char *op, const char *id) {
+  if (npw_agent_uri[strlen(npw_agent_uri) - 1] == '/')
+    snprintf(myurl, size, "%s%s?%s", baseurl, op, id);
+  else
+    snprintf(myurl, size, "%s/%s?%s", baseurl, op, id);
+
+  myurl[size] = 0;
+}
+
+void set_remote_connection_path(char *connection_path, const char *id) {
+  int ret_code;
+  struct MemoryStruct chunk;
+  char *keys[MAXKEYS];
+  char *values[MAXKEYS];
+  const char *host;
+  const char *port;
+  char myurl[MAX_URL_SIZE];
+  char parameters[MAX_URL_SIZE];
+
+  init_mem(keys, values, &chunk);
+
+  if (!npw_agent_uri)  // Using TCP but no remote HTTP agent
+    {
+      D(bug("set_remote_connection_path: npw_agent_uri is null\n"));
+      sprintf(connection_path, "%s:%d", NPW_RPC_DEFAULT_SERVER, return_rpc_port());
+      return;
+    }
+
+  D(bug("set_remote_connection_path from URL %s with id %s\n", npw_agent_uri, id));
+  snprintf(parameters, MAX_URL_SIZE, "id=%s", id);
+  build_url(myurl, MAX_URL_SIZE, npw_agent_uri, GET_RPC_HOST_PORT, parameters);
+
+  D(bug("set_remote_connection_path my url is \n", myurl));
+
+  ret_code = fetch_remote_agent_url(myurl, &chunk);
+  if (ret_code) {
+    npw_printf("ERROR: Error fetching url %s\n", npw_agent_uri);
+    return;
+  }
+
+  parse_page(&chunk, keys, values);
+  D(dump_keys(keys, values));
+
+  host = getvalue(keys, values, "host");
+  port = getvalue(keys, values, "port");
+
+  if (strlen(host) == 0) {
+    host = NPW_RPC_DEFAULT_SERVER;
+    npw_printf("ERROR: Error fetching key host from url %s. Setting to %s\n", npw_agent_uri, NPW_RPC_DEFAULT_SERVER);
+  }
+  if (strlen(port) == 0) {
+    port = "2111";
+    npw_printf("ERROR: Error fetching key port from url %s. Setting to %d\n", npw_agent_uri, NPW_RPC_DEFAULT_PORT);
+  }
+  sprintf(connection_path, "%s:%s", host, port);
+  D(bug("set_remote_connection_path from URL %s with connection_path %s\n", npw_agent_uri, connection_path));
+
+  free_mem(keys, values, &chunk);
+
+  return;
+}
+
+// Returns the remote pid, -1 if error
+// Parameters passed are the id and the execute string
+int invoke_remote_plugin(const char *exec_string, const char *id) {
+  int pid = -1, ret_code;
+  struct MemoryStruct chunk;
+  char *keys[MAXKEYS];
+  char *values[MAXKEYS];
+  const char *pid_str;
+  char myurl[MAX_URL_SIZE];
+  char parameters[MAX_URL_SIZE];
+
+  init_mem(keys, values, &chunk);
+
+  if (!npw_agent_uri)  // Using TCP but no remote HTTP agent
+    {
+      npw_printf("ERROR: invoke_remote_plugin no remote URL should never happen\n");
+      return -1;
+    }
+
+  D(bug("invoke_remote_plugin from URL %s with id %s\n", npw_agent_uri, id));
+  snprintf(parameters, MAX_URL_SIZE, "exec=%s&id=%s", exec_string, id);
+  build_url(myurl, MAX_URL_SIZE, npw_agent_uri, EXECUTE_REMOTE_PLUGIN, parameters);
+
+  D(bug("invoke_remote_plugin url is <%s>\n", myurl));
+
+  ret_code = fetch_remote_agent_url(myurl, &chunk);
+  if (ret_code) {
+    npw_printf("ERROR: Error fetching url %s\n", npw_agent_uri);
+    return -1;
+  }
+
+  parse_page(&chunk, keys, values);
+  D(dump_keys(keys, values));
+
+  pid_str = getvalue(keys, values, "pid");
+  pid = atoi (pid_str);
+
+  free_mem(keys, values, &chunk);
+  return pid;
+}
+
+int invoke_remote_kill(int pid, const char *id) {
+  int ret_code;
+  struct MemoryStruct chunk;
+  char *keys[MAXKEYS];
+  char *values[MAXKEYS];
+  const char *pid_str;
+  char myurl[MAX_URL_SIZE];
+  char parameters[MAX_URL_SIZE];
+
+  init_mem(keys, values, &chunk);
+
+  if (!npw_agent_uri)  // Using TCP but no remote HTTP agent
+    {
+      npw_printf("ERROR: invoke_remote_plugin no remote URL should never happen\n");
+      return -1;
+    }
+
+  D(bug("invoke_remote_kill from URL %s with id %s and pid %d\n", npw_agent_uri, id, pid));
+  snprintf(parameters, MAX_URL_SIZE, "pid=%d&id=%s", pid, id);
+  build_url(myurl, MAX_URL_SIZE, npw_agent_uri, EXECUTE_REMOTE_PLUGIN_KILL, parameters);
+
+  D(bug("invoke_remote_plugin url is <%s>\n", myurl));
+
+  ret_code = fetch_remote_agent_url(myurl, &chunk);
+  if (ret_code) {
+    npw_printf("ERROR: Error fetching url %s\n", npw_agent_uri);
+    return -1;
+  }
+
+  parse_page(&chunk, keys, values);
+  D(dump_keys(keys, values));
+
+  pid_str = getvalue(keys, values, "pid");
+  pid = atoi (pid_str);
+
+  free_mem(keys, values, &chunk);
+  return pid;
+}
+
+Window getChild_r(Window windowid, Display *display, unsigned int width, unsigned int height)
+{
+  Window *children, root_return, parent_return, *children_ptr, child;
+  unsigned int nchildren_return, i, border_width, depth,
+    children_width, children_height;
+  int x, y;
+
+
+  Status result = XQueryTree(display,
+			     windowid,
+			     &root_return,
+			     &parent_return,
+			     &children,
+			     &nchildren_return);
+  if (!result)
+    {
+      npw_printf("Error getting XQueryTree for id 0x%lx\n", windowid);
+      return (0);
+    }
+
+  printf("Num children for window id 0x%lx (%ux%u) : %d\n", windowid, width, height, nchildren_return);
+
+  for (i=0, children_ptr = children ; i < nchildren_return ; i ++)
+    {
+      printf("Child id: 0x%lx\n", *children_ptr);
+      result = XGetGeometry(display, *children_ptr, &root_return, &x, &y,
+			    &children_width, &children_height, &border_width,
+			    &depth);
+      if (!result)
+	{
+	  npw_printf("Error getting XGetGeometry for id 0x%lx\n", windowid);
+	  return (0);
+	}
+
+      if (children_width == width && children_height == height)
+	{
+	  printf("Child 0x%lx has the same height and width ast the parent. Traversing tree\n", *children_ptr);
+	  child = getChild_r(*children_ptr, display, width, height);
+	  XFree(children);
+	  if (child)
+	    return child;
+	  else
+	    return windowid;
+	}
+      else
+	{
+	  printf("Skipping child 0x%lx because the height and width are differnt\n", *children_ptr);
+	}
+      children_ptr ++;
+    }
+
+  XFree(children);
+  // Not found;
+  return windowid;
+}
+
+/*
+ * If no child exists of the same size it returns the same windowid
+ * It returns 0 on error
+ */
+Window getChild(Window windowid)
+{
+  Display  *display;
+  Window root_return;
+  unsigned int width, height, border_width, depth;
+  int x, y;
+
+  display = XOpenDisplay(0);
+  if (!display)
+    {
+      npw_printf("can't open display\n");
+      return (0);
+    }
+
+
+  Status result = XGetGeometry(display, windowid, &root_return, &x, &y,
+			&width, &height, &border_width, &depth);
+  if (!result)
+    {
+      npw_printf("Error getting XGetGeometry for id 0x%lx\n", windowid);
+      return (0);
+    }
+
+  return getChild_r(windowid, display, width, height);
+}
+
+Window getWindowidProp(Window windowid)
+{
+  const char *property = QVD_XPROP_TRANSLATION;
+  Atom     actual_type;
+  int      actual_format;
+  unsigned long  nitems;
+  unsigned long  bytes;
+  long     *data = NULL;
+
+  Display *display = XOpenDisplay(0);
+  if (!display)
+    {
+      npw_printf("can't open display\n");
+      return (0);
+    }
+
+  D(bug("getWindowidProp, trying to get property: %s\n", property));
+  Atom propertyAtom = XInternAtom(display, property, True);
+  D(bug("getWindowidProp, after getting property: %s, %ld\n", property, propertyAtom));
+  if (propertyAtom == None)
+    {
+      npw_printf("The Xwindows property %s does not exists\n", property);
+      return 0;
+    }
+  Status result = XGetWindowProperty(
+                display,
+                windowid,
+                propertyAtom, //replace this with your property
+                0,
+                (~0L),
+                False,
+                AnyPropertyType,
+                &actual_type,
+                &actual_format,
+                &nitems,
+                &bytes,
+                (unsigned char**)&data);
+  if (result != Success)
+    {
+      npw_printf("Error getting XGetWindowProperty %s for id 0x%lx\n", property, windowid);
+      return (0);
+    }
+  D(bug ("Data actual_type: %ld, format: %d, nitems: %ld, bytes: %ld, data: 0x%lx %ld\n", actual_type, actual_format, nitems, bytes, *data, *data));
+  if (nitems < 1 || data == NULL)
+    return 0;
+  return *data;
+}
+
+
+
+/*
+ * Receives as input the window id, and returns the same or the translated one
+ * On error the same windowid is returned. is this correct? (TODO)
+ */
+
+void *translate_parent_window_id(void *windowid, const char *id)
+{
+  Window new_windowid = getWindowidProp((Window)windowid);
+
+  if (new_windowid == 0)
+    {
+      new_windowid = (Window)windowid;
+      npw_printf("translate_parent_window_id returned null, setting the same windowid\n", new_windowid);
+    }
+
+  D(bug("translate_parent_window_id for id %s translated windowid for from %p->%p [%lx]\n", id, windowid, (void *)new_windowid, new_windowid));
+  return (void *)new_windowid;
+}
+/*
+void *translate_parent_window_id(void *windowid, const char *id)
+{
+  int ret_code;
+  struct MemoryStruct chunk;
+  char *keys[MAXKEYS];
+  char *values[MAXKEYS];
+  const char *windowid_str;
+  char myurl[MAX_URL_SIZE];
+  char parameters[MAX_URL_SIZE];
+  void *new_windowid;
+
+  npw_xwin_translate_service_uri = getenv(NPW_XWININFO_TRANSLATE_AGENT_ENV);
+  if (!npw_xwin_translate_service_uri) {
+      D(bug("translate_parent_window_id: not defined translation service env var: %s for id %s. Returning the same windowid %p", NPW_XWININFO_TRANSLATE_AGENT_ENV, id, windowid));
+      return windowid;
+  }
+
+  D(bug("translate_parent_window_id env var %s defined for id %s: %so. windowid=%p\n", NPW_XWININFO_TRANSLATE_AGENT_ENV, id, npw_xwin_translate_service_uri, windowid));
+
+  init_mem(keys, values, &chunk);
+  snprintf(parameters, MAX_URL_SIZE, "windowid=%p&id=%s", windowid, id);
+  build_url(myurl, MAX_URL_SIZE, npw_xwin_translate_service_uri, TRANSLATE_WINID_OP, parameters);
+
+  D(bug("translate_parent_window_id invoke_remote_plugin url is <%s>\n", myurl));
+  ret_code = fetch_remote_agent_url(myurl, &chunk);
+  if (ret_code) {
+    npw_printf("ERROR: Error fetching url %s\n", npw_agent_uri);
+    return windowid;
+  }
+
+  parse_page(&chunk, keys, values);
+  D(dump_keys(keys, values));
+  windowid_str = getvalue(keys, values, "windowid");
+  if (sscanf(windowid_str, "%p", &new_windowid) < 1) {
+    npw_printf("ERROR: translate_parent_window_id Unable to parse new windowid%s\n", windowid_str);
+    return windowid;
+  }
+
+  D(bug("translate_parent_window_id translated windowid for id %s from %p->%p\n", id, windowid, new_windowid));
+  return new_windowid;
+
+}
+
+*/
Index: nspluginwrapper-1.2.2/src/npw-remote-agent-info.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ nspluginwrapper-1.2.2/src/npw-remote-agent-info.h	2010-09-09 21:54:10.000000000 +0200
@@ -0,0 +1,58 @@
+/*
+ * npw-agent-info.h
+ *
+ * 21/8/2010 - Nito@Qindel.ES
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef NPW_AGENT_INFO_H
+#define NPW_AGENT_INFO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Use TCP/IP communication
+//#define NPW_RPC_USE_TCPIP 1
+#define NPW_RPC_DEFAULT_PORT 2111
+//#define NPW_RPC_TEST_PORT2 3111
+#define NPW_RPC_DEFAULT_SERVER "127.0.0.1"
+//#define NPW_RPC_TEST_SERVER2 "127.0.0.1"
+#define MAX_CONNECTION_PATH 128
+  // define This environment var to query the agent
+#define NPW_REMOTE_AGENT_ENV "NPW_REMOTE_AGENT_URI"
+#define GET_RPC_HOST_PORT "get_rpc_host_port"
+#define EXECUTE_REMOTE_PLUGIN "execute_plugin"
+#define EXECUTE_REMOTE_PLUGIN_KILL "kill_plugin"  // define the environment
+  // define xwindow translation service
+      //NPW_XWININFO_TRANSLATE_AGENT_ENV
+#define NPW_XWININFO_TRANSLATE_AGENT_ENV "NPW_NX_AGENT_URI"
+#define TRANSLATE_WINID_OP "translate"
+  // define This environment var to 1 to use TCP sockets
+#define NPW_USE_TCPIP_PORT "NPW_USE_TCPIP_PORT"
+#define QVD_XPROP_TRANSLATION "_QVD_CLIENT_WID"
+
+
+extern void set_remote_connection_path(char *connection_path, const char *id);
+extern int set_tcp_ip_and_remote_invocation_flags();
+extern int invoke_remote_plugin(const char *exec_string, const char *id);
+extern int invoke_remote_kill(int pid, const char *id);
+extern void *translate_parent_window_id(void *windowid, const char *id);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: nspluginwrapper-1.2.2/src/npw-use-tcp-sockets.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ nspluginwrapper-1.2.2/src/npw-use-tcp-sockets.c	2010-09-09 21:54:10.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+ * npw-use-tcp-sockets.c
+ *
+ *
+ * Note: Problem in compiling npw-remote-agent-info as 64bits... in 32bit
+ *
+ * 21/8/2010 - Nito@Qindel.ES
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include "sysdeps.h"
+#include "npw-use-tcp-sockets.h"
+#define DEBUG 1
+#include "debug.h"
+
+static int use_tcp_sockets_flag = 0;
+static int use_remote_invocation_flag = 0;
+
+int use_tcp_sockets() {
+  return use_tcp_sockets_flag;
+}
+
+int set_tcp_sockets() {
+  use_tcp_sockets_flag = 1;
+  return use_tcp_sockets_flag;
+}
+
+int unset_tcp_sockets() {
+  use_tcp_sockets_flag = 0;
+  return use_tcp_sockets_flag;
+}
+
+int use_remote_invocation() {
+  return use_remote_invocation_flag;
+}
+
+int set_remote_invocation() {
+  use_remote_invocation_flag = 1;
+  set_tcp_sockets();
+  return use_remote_invocation_flag;
+}
+
+int unset_remote_invocation() {
+  use_remote_invocation_flag = 0;
+  return use_remote_invocation_flag;
+}
+
Index: nspluginwrapper-1.2.2/src/npw-use-tcp-sockets.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ nspluginwrapper-1.2.2/src/npw-use-tcp-sockets.h	2010-09-09 21:54:10.000000000 +0200
@@ -0,0 +1,38 @@
+/*
+ * use-tcp-sockets.h
+ *
+ * 23/8/2010 - Nito@Qindel.ES
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef NPW_USE_TCP_SOCKETS_H
+#define NPW_USE_TCP_SOCKETS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int use_tcp_sockets();
+extern int set_tcp_sockets();
+extern int unset_tcp_sockets();
+extern int use_remote_invocation();
+extern int set_remote_invocation();
+extern int unset_remote_invocation();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: nspluginwrapper-1.2.2/Makefile
===================================================================
--- nspluginwrapper-1.2.2.orig/Makefile	2010-09-09 21:54:10.000000000 +0200
+++ nspluginwrapper-1.2.2/Makefile	2010-09-09 21:54:10.000000000 +0200
@@ -106,14 +106,18 @@
 
 npwrapper_LIBRARY = npwrapper.so
 npwrapper_RAWSRCS = npw-wrapper.c npw-common.c npw-malloc.c npw-rpc.c rpc.c debug.c utils.c npruntime.c
+npwrapper_RAWSRCS += npw-use-tcp-sockets.c npw-remote-agent-info.c
 npwrapper_SOURCES = $(npwrapper_RAWSRCS:%.c=$(SRC_PATH)/src/%.c)
 npwrapper_OBJECTS = $(npwrapper_RAWSRCS:%.c=npwrapper-%.os)
 npwrapper_CFLAGS  = $(CFLAGS) $(X_CFLAGS) $(MOZILLA_CFLAGS) $(GLIB_CFLAGS)
+npwrapper_CFLAGS += $(CURL_CFLAGS)
 npwrapper_LDFLAGS = $(X_LDFLAGS) $(libpthread_LDFLAGS) $(libsocket_LDFLAGS)
 npwrapper_LDFLAGS += $(GLIB_LDFLAGS)
+npwrapper_LDFLAGS += $(CURL_LDFLAGS)
 
 npviewer_PROGRAM = npviewer.bin
 npviewer_RAWSRCS = npw-viewer.c npw-common.c npw-malloc.c npw-rpc.c rpc.c debug.c utils.c npruntime.c
+npviewer_RAWSRCS += npw-use-tcp-sockets.c
 npviewer_SOURCES = $(npviewer_RAWSRCS:%.c=$(SRC_PATH)/src/%.c)
 npviewer_OBJECTS = $(npviewer_RAWSRCS:%.c=npviewer-%.o)
 ifeq ($(biarch),yes)
@@ -151,6 +155,7 @@
 
 npplayer_PROGRAM  = npplayer
 npplayer_SOURCES  = npw-player.c debug.c rpc.c utils.c glibcurl.c gtk2xtbin.c $(tidy_SOURCES)
+npplayer_SOURCES += npw-use-tcp-sockets.c
 npplayer_OBJECTS  = $(npplayer_SOURCES:%.c=npplayer-%.o)
 npplayer_CFLAGS   = $(GTK_CFLAGS) $(MOZILLA_CFLAGS) $(CURL_CFLAGS) $(X_CFLAGS)
 npplayer_LDFLAGS  = $(GTK_LDFLAGS) $(CURL_LDFLAGS) $(X_LDFLAGS)
@@ -201,7 +206,7 @@
 nploader_RAWSRCS = npw-viewer.sh
 nploader_SOURCES = $(nploader_RAWSRCS:%.sh=$(SRC_PATH)/src/%.sh)
 
-test_rpc_RAWSRCS		 = test-rpc-common.c debug.c rpc.c
+test_rpc_RAWSRCS		 = test-rpc-common.c debug.c rpc.c npw-use-tcp-sockets.c
 test_rpc_client_OBJECTS	 = $(test_rpc_RAWSRCS:%.c=%-client.o)
 test_rpc_server_OBJECTS	 = $(test_rpc_RAWSRCS:%.c=%-server.o)
 test_rpc_client_CPPFLAGS = $(CPPFLAGS) -I$(SRC_PATH)/src -DBUILD_CLIENT -DNPW_COMPONENT_NAME="\"Client\""
Index: nspluginwrapper-1.2.2/src/npw-wrapper.c
===================================================================
--- nspluginwrapper-1.2.2.orig/src/npw-wrapper.c	2010-09-09 21:54:08.000000000 +0200
+++ nspluginwrapper-1.2.2/src/npw-wrapper.c	2010-09-09 21:54:10.000000000 +0200
@@ -42,6 +42,8 @@
 #include <X11/Shell.h>
 #include <X11/StringDefs.h>
 
+#include "npw-use-tcp-sockets.h"
+#include "npw-remote-agent-info.h"
 #include "utils.h"
 #include "npw-common.h"
 #include "npw-malloc.h"
@@ -81,6 +83,7 @@
   char *name;
   char *description;
   char *formats;
+  char *unique_id;
 } Plugin;
 
 static Plugin g_plugin = { 0, -1, 0, NULL, NULL, NULL };
@@ -1956,6 +1959,22 @@
   if (plugin == NULL)
 	return NPERR_INVALID_INSTANCE_ERROR;
 
+  /*  D(bug("NPP_SetWindow instance=%p and x=%d, y=%d, w=%d, h=%d\n", instance, window->x, window->y, window->width, window->height));
+  D(bug("NPP_SetWindow pointers pdata=%p, ndata=%p\n",
+	instance->pdata,
+	instance->ndata));
+  D(bug("NPP_SetWindow pointers instance=%p", instance));
+  D(bug("NPP_SetWindow pointers plugin native_instance=%p", plugin->instance));
+  D(bug("NPP_SetWindow pointers plugin->pdata=%p, plugin->ndata=%p\n",
+  plugin->instance->pdata,plugin->instance->ndata));*/
+  if (use_remote_invocation())
+    {
+      D(bug("NPP_SetWindow remote_invocation=true before setting window->window=%p, ptr size=%d\n",
+	    window->window, sizeof(window->window)));
+      window->window = translate_parent_window_id(window->window, g_plugin.unique_id);
+      D(bug("NPP_SetWindow remote_invocation=true after setting window->window=%p, ptr size=%d\n",
+	    window->window, sizeof(window->window)));
+    }
   D(bugiI("NPP_SetWindow instance=%p\n", instance));
   NPError ret = invoke_NPP_SetWindow(plugin, window);
   D(bugiD("NPP_SetWindow return: %d [%s]\n", ret, string_of_NPError(ret)));
@@ -3327,7 +3346,7 @@
 	g_plugin.initialized = 1 + is_NP_Initialize;
 	return;
   }
-
+  D(bug("QVD after plugin_init check for default plugin_path\n", plugin_path));
   if (PLUGIN_DIRECT_EXEC){
 	g_plugin.initialized = 1;
 	return;
@@ -3350,10 +3369,25 @@
   ++init_count;
   char viewer_path[PATH_MAX];
   sprintf(viewer_path, "%s/%s/%s/%s", NPW_LIBDIR, NPW_Plugin.target_arch, NPW_Plugin.target_os, NPW_VIEWER);
+  char  unique_id_path[128];
   char connection_path[128];
   sprintf(connection_path, "%s/%s/%d-%d", NPW_CONNECTION_PATH, plugin_file_name, getpid(), init_count);
 
-  // Cache MIME info and plugin name/description
+  set_tcp_ip_and_remote_invocation_flags();
+
+  if (use_tcp_sockets())
+    {
+    // Use TCP sockets
+      sprintf(unique_id_path, "%s-%d-%d", plugin_file_name, getpid(), init_count);
+      set_remote_connection_path(connection_path, unique_id_path);
+    D(bug("QVD: plugin_init with test_server and test_port++ %s\n", connection_path));
+  } // End using tcp sockets
+  else
+    { // Using unix sockets
+      sprintf(connection_path, "%s/%s/%d-%d", NPW_CONNECTION_PATH, plugin_file_name, getpid(), init_count);
+      D(bug("QVD: plugin_init without test_server and test_port %s\n", connection_path));
+    }
+ // Cache MIME info and plugin name/description
   if (g_plugin.name == NULL && g_plugin.description == NULL && g_plugin.formats == NULL) {
 	char command[1024];
 	if (snprintf(command, sizeof(command), "%s --info --plugin %s", viewer_path, plugin_path) >= sizeof(command))
@@ -3403,7 +3437,22 @@
 	return;
 
   // Start plug-in viewer
-  if ((g_plugin.viewer_pid = fork()) == 0) {
+  if (use_remote_invocation())
+    {
+      char remote_exec[PATH_MAX];
+      D(bug("Invoking remote invocation for plugin\n"));
+      snprintf(remote_exec, PATH_MAX,
+	       "%s%%20--plugin%%20%s%%20--connection%%20%s%%20--remote-invocation", viewer_path, plugin_path, connection_path);
+      if ((g_plugin.viewer_pid = invoke_remote_plugin(remote_exec, unique_id_path)) < 0 )
+	{
+	  npw_printf("ERROR: failed to execute remote NSPlugin viewer\n");
+	  _Exit(255);
+	}
+      g_plugin.unique_id = strdup(unique_id_path);
+    }
+  else
+    {
+      if ((g_plugin.viewer_pid = fork()) == 0) {
 	char *argv[8];
 	int argc = 0;
 
@@ -3419,7 +3468,8 @@
 	execv(viewer_path, argv);
 	npw_printf("ERROR: failed to execute NSPlugin viewer\n");
 	_Exit(255);
-  }
+      }
+    }
 
   // Initialize browser-side RPC communication channel
   if ((g_rpc_connection = rpc_init_client(connection_path)) == NULL) {
@@ -3558,6 +3608,14 @@
   }
 
   if (g_plugin.viewer_pid != -1) {
+    if (use_remote_invocation())
+      {
+	D(bug("Invoking remote kill plugin\n"));
+	invoke_remote_kill(g_plugin.viewer_pid, g_plugin.unique_id);
+      }
+    else
+      {
+
 	// let it shutdown gracefully, then kill it gently to no mercy
 	const int WAITPID_DELAY_TO_SIGTERM = 3;
 	const int WAITPID_DELAY_TO_SIGKILL = 3;
@@ -3577,9 +3635,10 @@
 	  }
 	  sleep(1);
 	}
-	g_plugin.viewer_pid = -1;
+      }
+    g_plugin.viewer_pid = -1;
   }
-
+  free(g_plugin.unique_id);
   g_plugin.initialized = 0;
 }
 
Index: nspluginwrapper-1.2.2/src/rpc.c
===================================================================
--- nspluginwrapper-1.2.2.orig/src/rpc.c	2010-09-09 21:54:08.000000000 +0200
+++ nspluginwrapper-1.2.2/src/rpc.c	2010-09-09 22:02:07.000000000 +0200
@@ -42,10 +42,13 @@
 #include <sys/wait.h>
 #include <sys/select.h>
 #include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <arpa/inet.h>
 #include <pthread.h>
 #include <inttypes.h>
 #include <time.h>
 
+#include "npw-use-tcp-sockets.h"
 #include "rpc.h"
 #include "utils.h"
 
@@ -663,15 +666,59 @@
   return n;
 }
 
+// Return port number in int format from a string in format "ip:port"
+int _rpc_get_port_from_ident(const char *ident) {
+  int port;
+#define MAX_HOSTPORT_LEN 128
+  char host[MAX_HOSTPORT_LEN],format[32];
+  // Format string to parse chars
+  sprintf(format, " %%%d[^:]:%%d", MAX_HOSTPORT_LEN);
+
+  if (sscanf(ident, format, host, &port) != 2)
+    {
+      D(bug("_rpc_get_host_from_ident error parsing ident='%s' no port specified? port=%d\n", ident));
+      return -1;
+    }
+  set_tcp_sockets();
+  D(bug("_rpc_get_port_from_ident port returned for ident='%s' is %s [%d] and %d\n", ident, host, strlen(host), port));
+  return port;
+}
+
+int _rpc_get_host_from_ident(const char *ident, void *ptr) {
+  char host[MAX_HOSTPORT_LEN],format[32];
+  int port, server;
+  /*  char host[MAX_HOSTPORT_LEN],format[32]; */
+  // Format string to parse chars
+  sprintf(format, " %%%d[^:]:%%d", MAX_HOSTPORT_LEN);
+
+  if (sscanf(ident, format, host, &port) != 2)
+    {
+      D(bug("_rpc_get_host_from_ident error parsing ident='%s' no port specified?\n", ident));
+      return -1;
+    }
+  if ((server = inet_pton(AF_INET, host, ptr)) < 0) {
+    perror("error: Converting address");
+    return server;
+	  }
+
+  D(bug("_rpc_get_host_from_ident Usint tcp_sockets host returned for ident = '%s' is %s, %d\n", ident, host, server));
+  set_tcp_sockets();
+  return server;
+}
+
 // Initialize server-side RPC system
 rpc_connection_t *rpc_init_server(const char *ident)
 {
-  D(bug("rpc_init_server ident='%s'\n", ident));
 
   rpc_connection_t *connection;
-  struct sockaddr_un addr;
+  int myport;
+  int setsockoptflag = 1;
+  struct sockaddr_in addr_inet;
+  struct sockaddr_un addr_unix;
+  struct sockaddr *addr;
   socklen_t addr_len;
 
+  D(bug("rpc_init_server ident='%s'\n", ident));
   if (ident == NULL)
 	return NULL;
 
@@ -699,23 +746,53 @@
 	return NULL;
   }
 
-  if ((connection->server_socket = socket(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC, 0)) < 0) {
+// If we are able to parse the port then use_tcp_sockets is true
+  myport = _rpc_get_port_from_ident(ident);
+  if (use_tcp_sockets())
+    {
+      D(bug("QVD: creating tcp socket on client\n"));
+      if ((connection->server_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
 	perror("server socket");
 	rpc_exit(connection);
 	return NULL;
-  }
+      }
+      if (setsockopt(connection->server_socket, IPPROTO_TCP, TCP_NODELAY, (char *)&setsockoptflag, sizeof(setsockoptflag)) < 0)
+	{
+	  perror("Error setting TCP_NODELAY");
+	  rpc_exit(connection);
+	  return NULL;
+	}
+      memset(&addr_inet, 0, sizeof(addr));
+      addr_inet.sin_family = AF_INET;
+      addr_inet.sin_port = htons(myport);
+      D(bug("QVD: sin_port is: %d, %d\n", myport, addr_inet.sin_port));
+      addr_inet.sin_addr.s_addr = INADDR_ANY;
+      addr_len = _rpc_socket_path(&connection->socket_path, ident);
+      addr_len = sizeof(addr_inet);
+      addr=(struct sockaddr *)&addr_inet;
+      D(bug("QVD: created server tcp socket on client pid: %d, socket: %d\n", getpid(), connection->server_socket));
+    } // use_tcp_sockets
+  else
+    { // unix sockets
+      if ((connection->server_socket = socket(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC, 0)) < 0) {
+	perror("server socket");
+	rpc_exit(connection);
+	return NULL;
+      }
+      D(bug("QVD: Unix socket on client: %d\n", use_tcp_sockets()));
 
-  memset(&addr, 0, sizeof(addr));
-  addr.sun_family = AF_UNIX;
-  connection->socket_path = NULL;
-  addr_len = _rpc_socket_path(&connection->socket_path, ident);
-  memcpy(&addr.sun_path[0], connection->socket_path, addr_len);
-  addr_len += offsetof(struct sockaddr_un, sun_path); /* though POSIX says size of the actual sockaddr structure */
+      memset(&addr_unix, 0, sizeof(addr_unix));
+      addr_unix.sun_family = AF_UNIX;
+      connection->socket_path = NULL;
+      addr_len = _rpc_socket_path(&connection->socket_path, ident);
+      memcpy(&addr_unix.sun_path[0], connection->socket_path, addr_len);
+      addr_len += offsetof(struct sockaddr_un, sun_path); /* though POSIX says size of the actual sockaddr structure */
+      addr=(struct sockaddr *)&addr_unix;
 #ifdef HAVE_SOCKADDR_UN_SUN_LEN
-  addr.sun_len = addr_len;
+      addr_unix.sun_len = addr_len;
 #endif
-
-  if (bind(connection->server_socket, (struct sockaddr *)&addr, addr_len) < 0) {
+	} //unix_sockets
+  if (bind(connection->server_socket, addr, addr_len) < 0) {
 	perror("server bind");
 	rpc_exit(connection);
 	return NULL;
@@ -737,8 +814,13 @@
   D(bug("rpc_init_client ident='%s'\n", ident));
 
   rpc_connection_t *connection;
-  struct sockaddr_un addr;
   socklen_t addr_len;
+  int server;
+  int myport;
+  struct sockaddr_in addr_inet;
+  struct sockaddr_un addr_unix;
+  struct sockaddr *addr;
+  int setsockoptflag = 1;
 
   if (ident == NULL)
 	return NULL;
@@ -766,37 +848,71 @@
 	return NULL;
   }
 
-  if ((connection->socket = socket(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC, 0)) < 0) {
+  // Parses ident, and if it is of the form [^:]+:\d+, then we assume TCP
+  myport = _rpc_get_port_from_ident(ident);
+  if (use_tcp_sockets())
+    {
+      if ((connection->socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
+	perror("server socket");
+	rpc_exit(connection);
+	return NULL;
+      }
+      D(bug("QVD: created tcp socket on client\n"));
+      if (rpc_set_non_blocking_io(connection->socket) < 0) {
+	perror("client socket set non-blocking");
+	rpc_exit(connection);
+	return NULL;
+      }
+      if (setsockopt(connection->socket, IPPROTO_TCP, TCP_NODELAY, (char *)&setsockoptflag, sizeof(setsockoptflag)) < 0) {
+	perror("Error setting TCP_NODELAY");
+	rpc_exit(connection);
+	return NULL;
+      }
+      memset(&addr_inet, 0, sizeof(addr));
+      addr_inet.sin_family = AF_INET;
+      addr_inet.sin_port = htons(myport);
+      if ((server = _rpc_get_host_from_ident(ident, &addr_inet.sin_addr)) <= 0) {
+	perror("error: Converting address");
+	rpc_exit(connection);
+	return NULL;
+      }
+      addr_len = _rpc_socket_path(&connection->socket_path, ident);
+      addr_len = sizeof(struct sockaddr_in);
+      addr = (struct sockaddr *)&addr_inet;
+    } // use_tcp_sockets
+  else
+    { // !use_tcp_sockets: unix sockets
+      if ((connection->socket = socket(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC, 0)) < 0) {
 	perror("client socket");
 	rpc_exit(connection);
 	return NULL;
-  }
-
-  if (rpc_set_non_blocking_io(connection->socket) < 0) {
+      }
+      if (rpc_set_non_blocking_io(connection->socket) < 0) {
 	perror("client socket set non-blocking");
 	rpc_exit(connection);
 	return NULL;
-  }
+      }
 
-  memset(&addr, 0, sizeof(addr));
-  addr.sun_family = AF_UNIX;
-  connection->socket_path = NULL;
-  addr_len = _rpc_socket_path(&connection->socket_path, ident);
-  memcpy(&addr.sun_path[0], connection->socket_path, addr_len);
-  addr_len += offsetof(struct sockaddr_un, sun_path); /* though POSIX says size of the actual sockaddr structure */
+      memset(&addr_unix, 0, sizeof(addr_unix));
+      addr_unix.sun_family = AF_UNIX;
+      connection->socket_path = NULL;
+      addr_len = _rpc_socket_path(&connection->socket_path, ident);
+      memcpy(&addr_unix.sun_path[0], connection->socket_path, addr_len);
+      addr_len += offsetof(struct sockaddr_un, sun_path); /* though POSIX says size of the actual sockaddr structure */
+      addr=(struct sockaddr *)&addr_unix;
 #ifdef HAVE_SOCKADDR_UN_SUN_LEN
-  addr.sun_len = addr_len;
+      addr_unix.sun_len = addr_len;
 #endif
-
+    }
   // Wait at most RPC_INIT_TIMEOUT seconds for server to initialize
   const int N_CONNECT_WAIT_DELAY = 10;
   int n_connect_attempts = (rpc_init_timeout() * 1000) / N_CONNECT_WAIT_DELAY;
   if (n_connect_attempts == 0)
 	n_connect_attempts = 1;
   while (n_connect_attempts > 0) {
-	if (connect(connection->socket, (struct sockaddr *)&addr, addr_len) == 0)
+	if (connect(connection->socket, addr, addr_len) == 0)
 	  break;
-	if (n_connect_attempts > 1 && errno != ECONNREFUSED && errno != ENOENT) {
+	if (n_connect_attempts > 1 && errno != ECONNREFUSED && errno != ENOENT  && errno != EINPROGRESS && errno != EALREADY) {
 	  perror("client_connect");
 	  rpc_exit(connection);
 	  return NULL;
@@ -917,10 +1033,24 @@
   if (connection->type != RPC_CONNECTION_SERVER)
 	return RPC_ERROR_CONNECTION_TYPE_MISMATCH;
 
-  struct sockaddr_un addr;
-  socklen_t addr_len = sizeof(addr);
-  if ((connection->socket = accept(connection->server_socket, (struct sockaddr *)&addr, &addr_len)) < 0)
-	return RPC_ERROR_ERRNO_SET;
+  struct sockaddr_in addr_inet;
+  struct sockaddr_un addr_unix;
+  struct sockaddr *addr;
+  socklen_t addr_len;
+
+  if (use_tcp_sockets())
+    {
+      addr_len = sizeof(addr_inet);
+      addr = (struct sockaddr *) &addr_inet;
+    }
+  else // !use_tcp_sockets: unix_socket
+    {
+      addr_len = sizeof(addr_unix);
+      addr = (struct sockaddr *) &addr_unix;
+    }
+
+  if ((connection->socket = accept(connection->server_socket, addr, &addr_len)) < 0)
+    return RPC_ERROR_ERRNO_SET;
 
   if (rpc_set_non_blocking_io(connection->socket) < 0)
 	return RPC_ERROR_ERRNO_SET;
@@ -2534,6 +2664,12 @@
 
 int main(void)
 {
+  // Need to rewrite the connection path for testing
+  if (use_tcp_sockets())
+    {
+      fprintf(stderr, "TCP sockets testing still not implemented\n");
+      return(1);
+    }
   sprintf(g_npn_connection_path, "/org/wrapper/NSPlugin/NPN/%d", getpid());
   sprintf(g_npp_connection_path, "/org/wrapper/NSPlugin/NPP/%d", getpid());
 
Index: nspluginwrapper-1.2.2/src/npw-viewer.c
===================================================================
--- nspluginwrapper-1.2.2.orig/src/npw-viewer.c	2010-09-09 21:54:08.000000000 +0200
+++ nspluginwrapper-1.2.2/src/npw-viewer.c	2010-09-09 21:54:10.000000000 +0200
@@ -44,7 +44,7 @@
 #include "xembed.h"
 #include "npw-common.h"
 #include "npw-malloc.h"
-
+#include "npw-use-tcp-sockets.h"
 #define DEBUG 1
 #include "debug.h"
 
@@ -574,6 +574,192 @@
 
   // create the new window
   if (plugin->use_xembed) {
+    if (use_remote_invocation())
+      {
+	/*	void *container, *socket;
+	printf("The window id of the parent is: %p\n", window->window);
+	printf("Enter separated by space the windowid of the container and the windowid of the socket:");
+	scanf("%p %p", &container, &socket);
+	printf("The ids passed were %p and %p\n", container, socket);
+	window->window = socket;
+	*/
+	/*
+	GtkData *toolkit = calloc(1, sizeof(*toolkit));
+	if (toolkit == NULL)
+	  return -1;
+	toolkit->container = gtk_window_new (GTK_WINDOW_POPUP);
+	toolkit->socket = gtk_socket_new();
+	gtk_container_add (GTK_CONTAINER (toolkit->container), toolkit->socket);
+	gtk_widget_set_size_request (toolkit->socket, window->width, window->height);
+	gtk_widget_show (toolkit->socket);
+	gtk_widget_realize (toolkit->container);
+	GdkWindow* window_container = gdk_window_foreign_new((Window)window->window);
+	if (GTK_WIDGET_MAPPED(toolkit->container))
+	  gtk_widget_unmap(toolkit->container);
+	    
+	gdk_window_reparent(toolkit->container->window, window_container, 0, 0);
+	gtk_widget_show (toolkit->container);
+	
+	window->window = (void *)gtk_socket_get_id(GTK_SOCKET(toolkit->socket));
+	plugin->toolkit_data = toolkit;
+#if USE_XEMBED_HACK
+	// don't let the browser kill our window out of NPP_Destroy() scope
+	g_signal_connect(toolkit->container, "delete-event",
+			 G_CALLBACK(gtk_true), NULL);
+#endif
+	// make sure we don't try to destroy the widget again in destroy_window()
+	g_signal_connect(toolkit->container, "destroy",
+			 G_CALLBACK(gtk_widget_destroyed), &toolkit->container);
+	// keep the socket as the plugin tries to destroy the widget itself
+	g_signal_connect(toolkit->socket, "plug_removed",
+			 G_CALLBACK(gtk_true), NULL);
+
+	window->window = (void *)gtk_socket_get_id(GTK_SOCKET(toolkit->socket));
+	plugin->toolkit_data = toolkit;
+	
+	return(0);
+	*/
+	GtkData *toolkit = calloc(1, sizeof(*toolkit));
+	if (toolkit == NULL)
+	  return -1;
+	D(bug("create_window Before creationg toolkit->container\n"));
+	//toolkit->container = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+	toolkit->container = gtk_window_new (GTK_WINDOW_POPUP);
+	// gdk_window_set_override_redirect(toolkit->container->window, TRUE);
+	if (toolkit->container == NULL)
+	  return -1;
+	D(bug("create_window Before realizing toolkit->container\n"));
+	//D(bug("can focus container: %d\n", gtk_widget_get_can_focus(toolkit->container)));
+	//gtk_widget_set_can_focus(toolkit->container, TRUE);
+	//D(bug("can focus container: %d\n", gtk_widget_get_can_focus(toolkit->container)));
+	//D(bug("event mask container: 0x%x\n", gtk_widget_get_events(toolkit->container)));
+	//gtk_widget_add_events(toolkit->container, GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK);
+	//D(bug("event mask container after adding : 0x%x\n", gtk_widget_get_events(toolkit->container)));
+	//gtk_widget_set_events(toolkit->container, GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_MOTION_MASK |  GDK_BUTTON1_MOTION_MASK | GDK_BUTTON2_MOTION_MASK | GDK_BUTTON3_MOTION_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK);
+	//	D(bug("event mask container: %d\n", gtk_widget_get_events(toolkit->container)));
+	gtk_widget_realize(toolkit->container);
+	D(bug("create_window Before set size_request toolkit->container\n"));
+ 	gtk_widget_set_size_request(toolkit->container, window->width, window->height);
+	D(bug("create_window Before gdk_window_foreign_new window %p\n", window->window));
+	GdkWindow *parent = gdk_window_foreign_new((Window)window->window);
+	//	D(bug("create_window Before set showing parent window \n"));
+	//gtk_widget_show(parent);
+	//D(bug("event mask parent: %d\n", gtk_widget_get_events(parent)));
+	//gtk_widget_set_events(parent, 0x0fffff);
+	//D(bug("event mask parent: %d\n", gtk_widget_get_events(parent)));
+	D(bug("create_window Before reparent toolkit->container %p->%p\n", GDK_WINDOW_XID(toolkit->container->window), window->window));
+	gdk_window_reparent(toolkit->container->window, parent, 0, 0);
+	D(bug("create_window Before show toolkit->container\n"));
+	gtk_widget_show(toolkit->container);
+	D(bug("create_window container is: %p\n",  GDK_WINDOW_XID(toolkit->container->window)));
+
+	// Test
+	//	D(bug("create_window Create button\n"));
+	//GtkWidget *button;
+	//button = gtk_button_new_with_label ("Hello World");
+	//gtk_container_add (GTK_CONTAINER(toolkit->container), button);
+	//gtk_widget_show(button);
+	//gtk_widget_set_sensitive(toolkit->container, TRUE);
+	toolkit->socket = gtk_socket_new();
+	if (toolkit->socket == NULL)
+	  return -1;
+	//D(bug("event mask socket: %d\n", gtk_widget_get_events(toolkit->socket)));
+	// Careful not to pass all events -> the expose event kills the plugin
+	//	gtk_widget_set_events(toolkit->socket, 0x0fffff);
+	//D(bug("event mask socket: %d\n", gtk_widget_get_events(toolkit->socket)));
+	gtk_widget_set_size_request (toolkit->socket, window->width, window->height);
+	gtk_container_add(GTK_CONTAINER(toolkit->container), toolkit->socket);
+	gtk_widget_show (toolkit->socket);
+	D(bug("create_window socket is: %p\n", gtk_socket_get_id((GtkSocket *)toolkit->socket)));
+	D(bug("can focus before parent: %d, container: %d, socket: %d\n", GTK_WIDGET_CAN_FOCUS(parent),
+	      GTK_WIDGET_CAN_FOCUS(toolkit->container), GTK_WIDGET_CAN_FOCUS(toolkit->socket)));
+	//	gtk_widget_set_can_focus(parent, TRUE);
+	//	gtk_widget_set_can_focus(toolkit->container, TRUE);
+	//	gtk_widget_set_can_focus(toolkit->socket, TRUE);
+	D(bug("can focus after parent: %d, container: %d, socket: %d\n", GTK_WIDGET_CAN_FOCUS(parent),
+	      GTK_WIDGET_CAN_FOCUS(toolkit->container), GTK_WIDGET_CAN_FOCUS(toolkit->socket)));
+	D(bug("widget state parent: %d, container: %d, socket: %d\n", GTK_WIDGET_STATE(parent),
+	      GTK_WIDGET_STATE(toolkit->container), GTK_WIDGET_STATE(toolkit->socket)));
+	D(bug("widget sensitive parent: %d, container: %d, socket: %d\n", GTK_WIDGET_IS_SENSITIVE(parent),
+	      GTK_WIDGET_IS_SENSITIVE(toolkit->container), GTK_WIDGET_IS_SENSITIVE(toolkit->socket)));
+
+	//	gtk_widget_grab_focus(toolkit->container);
+	//gtk_widget_show_all(toolkit->container);
+	//gtk_widget_grab_focus(toolkit->container);
+	//gtk_widget_grab_focus(toolkit->container);
+
+	D(bug("create_window parent window=0x%lx, container=0x%lx, socket=0x%lx\n", window->window, GDK_WINDOW_XID(toolkit->container->window), gtk_socket_get_id((GtkSocket *)toolkit->socket)));
+	//	D(bug("create_window parent window=0x%lx, container=0x%lx, socket=0x%lx\n", GDK_WINDOW_XID(window->window), GDK_WINDOW_XID(toolkit->container->window), GDK_WINDOW_XID(toolkit->socket->window)));
+	//	D(bug("create_window parent window=0x%lx, container=0x%lx, socket=0x%lx\n", window->window, toolkit->container->window, GDK_WINDOW_XID(toolkit->socket->window)));
+
+	window->window = (void *)gtk_socket_get_id(GTK_SOCKET(toolkit->socket));
+	plugin->toolkit_data = toolkit;
+#if USE_XEMBED_HACK
+	// don't let the browser kill our window out of NPP_Destroy() scope
+	g_signal_connect(toolkit->container, "delete-event",
+					 G_CALLBACK(gtk_true), NULL);
+#endif
+	// make sure we don't try to destroy the widget again in destroy_window()
+	g_signal_connect(toolkit->container, "destroy",
+					 G_CALLBACK(gtk_widget_destroyed), &toolkit->container);
+	// keep the socket as the plugin tries to destroy the widget itself
+	g_signal_connect(toolkit->socket, "plug_removed",
+					 G_CALLBACK(gtk_true), NULL);
+	return 0;
+	/*	XtData *toolkit = calloc(1, sizeof(*toolkit));
+	if (toolkit == NULL)
+	  return -1;
+
+	String app_name, app_class;
+	
+	D(bug("Before XtGetApplicationNameAndClass\n"));
+	XtGetApplicationNameAndClass(x_display, &app_name, &app_class);
+	D(bug("Before top_widget\n"));
+	Widget top_widget = XtVaAppCreateShell("drawingArea", app_class, topLevelShellWidgetClass, x_display,
+					       XtNoverrideRedirect, True,
+					       XtNborderWidth, 0,
+					       XtNbackgroundPixmap, None,
+					       XtNwidth, window->width,
+					       XtNheight, window->height,
+					       NULL);
+	
+	D(bug("Before realize top_widget\n"));
+	XtRealizeWidget(top_widget);
+	D(bug("Before form. top widget is 0x%x\n", XtWindow(top_widget)));
+	Widget form = XtVaCreateManagedWidget("form", compositeWidgetClass, top_widget,
+					      XtNdepth, ws_info->depth,
+					      XtNvisual, ws_info->visual,
+					      XtNcolormap, ws_info->colormap,
+					      XtNborderWidth, 0,
+					      XtNbackgroundPixmap, None,
+					      XtNwidth, window->width,
+					      XtNheight, window->height,
+					      NULL);
+
+	D(bug("Before realize top_widget and form is 0x%x\n", XtWindow(form)));
+	XtRealizeWidget(top_widget);
+	D(bug("Before reparent window->window is 0x%x\n", window->window));
+	XReparentWindow(x_display, XtWindow(top_widget), (Window)window->window, 0, 0);
+	D(bug("Before realize form\n"));
+	XtRealizeWidget(form);
+	
+	D(bug("Before XSelectInput\n"));
+	XSelectInput(x_display, XtWindow(top_widget), 0x0fffff);
+	D(bug("Before XAddEventHandler\n"));
+	XtAddEventHandler(top_widget, (SubstructureNotifyMask|KeyPress|KeyRelease), True, xt_client_event_handler, toolkit);
+	XtAddEventHandler(form, (ButtonReleaseMask), True, xt_client_event_handler, toolkit);
+	xt_client_set_info(form, 0);
+
+	plugin->toolkit_data = toolkit;
+	toolkit->top_widget = top_widget;
+	toolkit->form = form;
+	toolkit->browser_window = (Window)window->window;
+	window->window = (void *)XtWindow(form);
+	return 0;
+	*/
+      }
+    else
+      {
 	GtkData *toolkit = calloc(1, sizeof(*toolkit));
 	if (toolkit == NULL)
 	  return -1;
@@ -602,6 +788,8 @@
 	g_signal_connect(toolkit->socket, "plug_removed",
 					 G_CALLBACK(gtk_true), NULL);
 	return 0;
+
+      }
   }
 
   XtData *toolkit = calloc(1, sizeof(*toolkit));
@@ -679,6 +867,12 @@
 	if (plugin->toolkit_data) {
 	  if (plugin->use_xembed) {
 		// window size changes are already caught per the XEMBED protocol
+	        if (use_remote_invocation())
+		  {
+		    GtkData *toolkit = plugin->toolkit_data;
+		    gtk_widget_set_size_request (toolkit->container, window->width, window->height);
+		    gtk_widget_set_size_request (toolkit->socket, window->width, window->height);
+		  }
 	  }
 	  else {
 		XtData *toolkit = (XtData *)plugin->toolkit_data;
@@ -4004,7 +4198,7 @@
 	CMD_HELP
   };
   int cmd = CMD_RUN;
-
+  unset_remote_invocation();
   // Parse command line arguments
   for (int i = 0; i < argc; i++) {
 	const char *arg = argv[i];
@@ -4034,6 +4228,10 @@
 		argv[i] = NULL;
 	  }
 	}
+	else if (strcmp(arg, "-r") == 0 || strcmp(arg, "--remote-invocation") == 0) {
+	  argv[i] = NULL;
+	  set_remote_invocation();
+	}
   }
 
   // Remove processed arguments
