
= La API del sistema de administración de QVD4


== Estructura general


La API es una aplicación `Mojolicious::Lite` definida en el archivo `wat.pl`. Es una interfaz REST que recibe una _query_ en formato JSON, ejecuta la tarea  correspondiente a esa petición, y devuelve a su vez un JSON como respuesta. El cerebro de la aplicación es un objeto `QVD::Admin4::REST`. Cuando la API recibe una _query_, se la pasa a este objeto, que será el encargado de orquestar todo el procesamiento y devolver una respuesta. Concretamente, el objeto `QVD::Admin4::REST` articula las siguientes clases para llevar a cabo su cometido: `QVD::Admin4::Action`, `QVD::Admin4::REST::Model`, `QVD::Admin4::REST::Request` y `QVD::Admin4`. 

`QVD::Admin4` proporciona todos los métodos que en última instancia ejecutan las acciones que piden las _queries_. Por tanto, pudiera decirse que `QVD::Admin4::REST`, al recibir una petición, se la pasa como argumento a un método de `QVD::Admin4` y devuelve el resultado que arroja este. 

Pero la realidad es más compleja. Téngase en cuenta que a cada acción soportada por la API le corresponde un método concreto de `QVD::Admin4`. Así pues, ¿cómo se establece la correspondencia entre el nombre de la acción solicitada en la _query_ y el método que debe ejecutarse en `QVD::Admin4`?  Del siguiente modo. Tomando como parámetro el nombre de la acción solicitada, se crea un nuevo objeto `QVD::Admin4::Action`. Este objeto proporciona la configuración básica de la acción en cuestión. Entre otras cosas, especifica el método de `QVD::Admin4` a utilizar.

Además, de acuerdo con otras especificaciones proporcionadas por el objeto `QVD::Admin4::Action`, se crea un objeto `QVD::Admin4::REST::Model`: un modelo que define cómo debe ser una acción del tipo especificado. Este modelo se utilizará para comprobar que la petición recibida es legítima, y para ajustarla al formato que esperan los métodos de `QVD::Admin4`.

Así pues, la _query_ que recibe `QVD::Admin4::REST` no es exactamente la que este le pasa al método de `QVD::Admin4`. En realidad, la _query_ se les pasa a estos métodos en forma de objeto `QVD::Admin4::REST::Request`. Este objeto representa una _query_ correcta y expresada en un formato concreto. El constructor del objeto `QVD::Admin4::REST::Request` toma como parámetros la _query_ y su modelo `QVD::Admin4::REST::Model` correspondiente. Siempre a partir del modelo, comprueba que la _query_ sea correcta y la traduce al formato necesario. Esta versión corregida y adaptada de la _query_ es lo que se  pasa como argumento al método de `QVD::Admin4` que ejecuta la acción.

En resumen, la API recibe una _query_ en formato JSON. Esta _query_ se le pasa al objeto `QVD::Admin4::REST`, encargado de gestionarla y devolver una respuesta. Este objeto recupera cierta información relevante sobre la acción solicitada, en forma de objetos `QVD::Admin4::Action` y `QVD::Admin4::REST::Model`. Con dicha información crea un objeto `QVD::Admin4::REST::Request` (una nueva versión de la _query_,  corregida y ajustada a un determinado formato). A continuación, ejecuta el método de `QVD::Admin4` correspondiente a la acción solicitada pasándole como argumento el objeto `QVD::Admin4::REST::Request`. La salida de ese método es lo que la API devuelve como respuesta, también en formato JSON.

=== La clase `QVD::Admin4::REST::JSON`

La API recibe la _query_ en formato JSON. Lo primero que hace el sistema con este JSON es crear un objeto de tipo `QVD::Admin4::REST::JSON`. Es un _wrapper_ que permite gestionar la _query_ con facilidad. Una vez creado el objeto, toda la información que se quiera sacar de la _query_ se le consultará a este. Por comodidad, en la documentación se habla de la _query_ de entrada. En realidad, esas alusiones hacen referencia al objeto  `QVD::Admin4::REST::JSON` que hace de _wrapper_ de la _query_ original.

=== La clase `QVD::Admin4::Action`

Un objeto `QVD::Admin4::Action` se crea con un parámetro obligatorio `name` (el nombre de la acción que se está pidiendo realizar, tomado de la _query_). Este objeto contiene la información básica, de arranque, de la acción que se ha solicitado. Concretamente, cuenta con los siguientes atributos:

* El atributo `type_of_action` establece el tipo de  acción solicita (hay acciones de visualización, de creación, de actualización, de borrado...). 

* El atributo `qvd_object` establece el tipo de objeto de QVD al que la acción afecta: `vm`, `user`, `osf`, `di`, `host`, etc. 

* El atributo `restmethod` establece el método que debe ejecutarse en `QVD::Admin4::REST` para invocar la acción.

* El atributo `admin4method` establece el método que debe ejecutarse en `QVD::Admin4` para invocar la acción.

La clase `QVD::Admin4::Action` define una lista cerrada de posibles acciones que la API permite realizar. El nombre de la acción solicitada se le pasa al constructor de `QVD::Admin4::Action` en el parámetro `name`. Si el valor de `name` no estuviera contemplado en la lista de acciones disponibles, la creación del objeto `QVD::Admin4::Action` fallaría. Este es el sistema que comprueba  que las peticiones que se hacen a la API estén soportadas por ella. En la clase `QVD::Admin4::Action`  también se codifican, para cada acción disponible en la API, los acls necesarios para ejecutarla. Una vez creado el objeto, se comprueba que el administrador que hace la petición cuente con los permisos necesarios. En caso contrario, se lanza un error.

=== La clase `QVD::Admin4::REST::Model`

La clase `QVD::Admin4::REST::Model` es un repositorio de información donde se especifica, para cada tipo de acción, qué filtros admite esta acción, qué argumentos, qué criterios de ordenación; qué campos devuelve; qué valores por defecto pudieran tener esos elementos; qué acls necesita un administrador para usarlos; cómo se traduce cada uno de ellos al formato adecuado para consultar a la base de datos (`DBIx::Class`), etc. Toda esta información se guarda en la clase  `QVD::Admin4::REST::Model` en forma de variables de clase.  


Cuando se crea un objeto `QVD::Admin4::REST::Model`, se le pasan al constructor los parámetros `qvd_object` y `type_of_action`. El valor de estos parámetros determina el tipo de acción para el que se crea el objeto, y con ello, el tipo de información que se debe cargar en él. En concreto, se toma de las variables de clase la información correspondiente  a los valores de estos parámetros y se crea un repositorio con esa información.  Después, el objeto creado cuenta con una serie de métodos _accessors_ que permiten consultar el repositorio: `available_filters` devuelve la lista de filtros disponibles, `available_filter` chequea si un filtro concreto está disponible, `get_acls_for_filter` devuelve los acls necesarios para usar un filtro concreto, `map_filter_to_dbix_format` devuelve la traducción de un filtro al formato de `DBIx::Class`, etc.

=== La clase `QVD::Admin4::REST::Request`

Una vez creados el _wrapper_ para la _query_ de entrada (`QVD::Admin4::REST::JSON`) y el modelo de la acción solicitada (`QVD::Admin4::REST::Model`) ya es posible crear una petición de tipo `QVD::Admin4::REST::Request`. Este objeto será lo que se le pase como argumento al método encargado de ejecutar la acción (un método de `QVD::Admin4`). Representa una petición que puede hacerse a la base de datos a través de `DBIx::Class`. Provee toda la información necesaria para efectuar la petición: tabla a la que consultar, _joins_ de otras tablas, filtros, argumentos si los hubiera, criterios de ordenación, etc. Este objeto se construye cotejando la _query_ de entrada con el modelo correspondiente. Su constructor lanza una serie de chequeos que comprueban que, conforme al modelo, la _query_ es correcta: los filtros, argumentos... son adecuados; y el administrador que hace la petición tiene acls suficientes para utilizar esos elementos. También se fuerzan, cuando es necesario, ciertos filtros, como el de tenant (un administrador de tenant solo debe poder ver la información de su tenant). Además, se traducen los elementos de la _query_ al formato utilizado por `DBIx::Class`.


==== El filtrado por tenant

Uno de los cometidos cruciales de la clase `QVD::Admin4::REST::Request` es forzar el filtrado por tenant. Un administrador puede ser o no superadministrador. Lo que caracteriza a un superadministrador es su asociación con el tenant de `id`  0 (desde ahora tenant 0). Cualquier administrador asociado a un tenant distinto de 0 no es un superadministrador. A efectos funcionales, la diferencia entre un administrador normal y un superadministrador es el ámbito sobre el que pueden operar.

* El ámbito de un superadministrador es el conjunto de los tenants del sistema.

* El ámbito de un administrador normal es exclusivamente el tenant al que está asociado.  

Un administrador puede efectuar todas las operaciones que le permitan sus acls. Pero esas operaciones las podrá efectuar solo dentro de su ámbito. Así pues, un administrador del tenant 1 con acls para crear máquinas virtuales podrá crear máquinas virtuales, pero solo dentro del tenant 1. Además, si dicho administrador tiene acls para ver las máquinas virtuales, podrá ver solo las máquinas virtuales del tenant 1. En cambio un superadministrador con los mismos acls podrá crear las máquinas virtuales en cualquiera de los tenants del sistema, y podrá ver las máquinas virtuales de todos los tenants.

Esto tiene ciertas implicaciones a la hora de crear las _queries_ que un administrador manda a la API. Un administrador normal debe obviar en todo caso el concepto de tenant. Las _queries_ que mande a la API no deben incluir filtros ni argumentos relativos al tenant. Será la API misma la que, en función del tenant del administrador, efectúe el filtrado oportuno o añada los argumentos oportunos. En cambio, un superadministrador sí debe contemplar el concepto de tenant: debe mandar en sus _queries_ los filtros y argumentos oportunos relativos al concepto de tenant.

El control sobre estas cuestiones lo efectúa la clase `QVD::Admin4::REST::Request`. Un objeto de esta clase representa una petición a la base de datos. Así pues, cuando se construye esta petición es necesario comprobar que el filtrado por tenant es el adecuado para el administrador que efectúa la petición, o que los objetos a crear se crearán en cada caso en el tenant adecuado. Para ello, `QVD::Admin4::REST::Request` efectúa una serie de operaciones sobre la _query_ de entrada:

* Si el administrador es superadministrador y fuera necesario para la acción solicitada, se comprueba si la _query_ tiene el filtro o argumento necesario relativo al tenant sobre el que operar. 
* Si el administrador no es superadministrador, se comprueba que la _query_ no incluya especificaciones sobre el tenant en el que operar.
* Si el administrador no es superadministrador y la acción lo requiere, se añade un filtro o argumento que restrinja el tenant sobre el que operar. El valor de ese filtro o argumento será el correspondiente al tenant del administrador. 

=== La clase `QVD::Admin4::REST`

Una vez creado el objeto `QVD::Admin4::REST::Request`, se ejecuta propiamente la acción solicitada. Para ello, se usan los atributos `restmethod` y `admin4method` del objeto `QVD::Admin4::Action` que representa a la acción. El atributo `restmethod` especifica el nombre de un método de `QVD::Admin4::REST` (en adelante *R*). Y el atributo `admin4method` especifica el nombre de un método de `QVD::Admin4` (en adelante *A*). Para ejecutar la acción, en primer lugar se ejecuta *R*, y dentro de *R* se ejecuta *A*. En realidad, es este segundo el método  que propiamente ejecuta la acción (la clase `QVD::Admin4` es la  que opera sobre la base de datos). La razón de que *A* no se ejecute directamente, sino a través de *R*, es que `QVD::Admin4` cuenta con distintos tipos de métodos, y cada uno de ellos se invoca de un modo distinto. El método *R* es el encargado de invocar *A* del modo adecuado.

Los métodos *R* posibles son:

* `process_standard_query`, para las acciones de funcionamiento regular, la inmensa mayoría.
* `process_ad_hoc_query`, para acciones de funcionamiento particular. 
* `process_multiple_query`, para acciones que requieren la ejecución de múltiples métodos *A*. 

Los métodos *A* pueden llegar a ser muchos, pero la inmensa mayor parte de las acciones de funcionamiento regular usan los mismos métodos: `select`, `update`, `create`, `create_or_update`, `delete`. En realidad, los objetos `QVD::Admin4::REST::Model` y `QVD::Admin4::REST::Request` vistos arriba están pensados solo para las acciones regulares (ejecutadas desde `process_standard_query`). De hecho, el objeto  `QVD::Admin4::REST::Request` se crea en `process_standard_query`. El resto de acciones (ejecutadas desde `process_ad_hoc_query` y `process_multiple_query`) se ejecutan mediante métodos _ad hoc_ que efectúan sus chequeos de forma independiente. En concreto, estos métodos toman como argumento un objeto de tipo `QVD::Admin4::REST::JSON`.

=== La clase `QVD::Admin4`

La clase `QVD::Admin4` no es mucho más que un conjunto de funciones. Estas son las funciones que, en última instancia, ejecutan las acciones que se solicitan a la API. 

==== Métodos regulares

La mayor parte de estas funciones efectúan una operación contra la base de datos (a través de `DBIx::Class`) y devuelven el resultado que esta arroja. Hay cinco funciones principales, encargadas de ejecutar la inmensa mayor parte de las aciones:

* `delete` borra objetos de la base de datos.

* `create` crea objetos nuevos en la base de datos.

* `update` actualiza información de la base de datos.

* `create_or_update` intenta actualizar un objeto, pero si este no existiese, lo crea. Se utiliza solo para algunos objetos del sistema para los cuales esta abstracción se ha visto útil (_tokens_ de configuración).

* `select` devuelve información de la base de datos. 


Además, existen otros métodos que en última instancia ejecutan  esas funciones principales , pero que, además, efectúan chequeos u operaciones extra. Por ejemplo, los métodos `vm_delete` o `di_delete` son los encargados de ejecutar las acciones de borrado de  `vm` y `di`. En definitiva, estos métodos ejecutan el método regular `delete`, pero establecen ciertas condiciones extra que han de cumplir los objetos para que de hecho se puedan borrar. Por su parte, el método  `di_create` crea un `di` lanzando el método `create`, pero, además, crea las _tags_ de ese `di` y actualiza su columna `path`. 

Por último, existen en la clase métodos de ejecución de máquinas virtuales: `vm_start`, `vm_stop` y `vm_user_disconnect`.

Todas estas acciones regulares, como ya se ha dicho, reciben como argumento un objeto `QVD::Admin4::REST::Request` que representa la _query_ de entrada. Este objeto proporciona varios _accessors_ cruciales que devuelven la información necesaria para hacer las peticiones a través de `DBIx::Class` :

* `table` establece el `Schema` contra el cual se debe ejecutar la consulta a la base de datos.
* `filters` define los filtros de las peticiones.
* `modifiers` define otros rasgos necesarios para definir adecuadamente una petición (_join_, _prefetch_, _order_, etc.).  
* `arguments` define los argumentos necesarios en las funciones de creación o actualización.
* `related_objects_arguments` define los argumentos necesarios en las funciones de creación o actualización que no se encuentran en la base de datos en la tabla propia del objeto afectado, sino en una tabla relacionada.

El diseño del método `select`  ha tenido que solucionar cuestiones de eficiencia. Lo hace de dos modos:

* Ante la consulta a una tabla de la base de datos, `DBIx::Class` devuelve un conjunto de objetos. Normalmente, parte de la información de esos objetos reside en tablas relacionadas con la tabla original. Por ello, para que el objeto en cuestión pueda devolver tal información tiene que hacer consultas extra a la base de datos. Cuando se devuelve un número considerable de objetos, las consultas se multiplican y el tiempo de respuesta se dispara. La solución es usar el rasgo _prefetch_ de `DBIx::Class`. Este rasgo permite recoger esa información relacionada directamente en la primera consulta. El  _prefetch_ para cada acción se codifica en la clase `QVD::Admin4::REST::Model` y se le pasa al método `select` mediante el objeto `QVD::Admin4::REST::Request`.
* Pero cierta  información relacionada con un objeto, la que se encuentra en una relación de uno a muchos, no puede seleccionarse mediante el rasgo _prefetch_. Por ejemplo, una `vm` puede tener muchas `properties`. Pues bien, estas `properties` no pueden extraerse en una única consulta junto a la `vm`. Por ello, este tipo de información nunca se extrae de la consulta principal a la base de datos. En cambio, se ha diseñado un sistema que, en una segunda consulta, extrae la información extra pesada. Esta segunda consulta utiliza una vista. Cada objeto de QVD con información pesada cuenta con una vista que devuelve esa información. Una vez hechas la consulta principal y la consulta extra, la información de la segunda se le inyecta al resultado de la primera. De nuevo, es en `QVD::Admin4::REST::Model` donde se codifica qué vista se relaciona con cada objeto de QVD; y es a través de `QVD::Admin4::REST::Request` como se hace llegar esa información al método `select`.

Los métodos `create` y `update` no solo permiten crear y actualizar objetos. También permiten establecer relaciones entre estos objetos y otros objetos del sistema. Estas operaciones se han llamado _nested queries_ (son acciones secundarias, anidadas en la petición principal). Las _nested quieries_ existentes en el sistema son de tres tipos:

* Asignación y borrado de _custom properties_ para `vm`, `user`, `di`, `osf`, `host`.

* Asignación y eliminación de _tags_ para `di`.

* Asignación y desasignación acls y roles para administradores y roles.

La API admite _nested queries_ para ciertas acciones. En la sintaxis de la API, estas _nested queries_ se codifican como argumentos con una clave especial, reservada. Si la _query_ cuenta con argumentos de este estilo, los métodos  `create` y `update`, además de efectuar sus operaciones principales, ejecutan funciones que llevan a cabo las asignaciones o desasignaciones de elementos oportunas.

==== Métodos irregulares

Hay otros métodos en `QVD::Admin4` que pudieran llamarse irregulares. Estos métodos no toman como argumento un objeto de tipo `QVD::Admin4::REST::Request`, sino de tipo `QVD::Admin4::REST::JSON`. Este objeto es una versión de la _query_ de entrada que no ha sido chequeada ni traducida al formato de `DBIx::Class`. Métodos de este tipo son, por ejemplo, aquellos que no trabajan contra la base de datos. Es el caso de  `config_get`, que devuelve los _tokens_ de configuración del sistema. Estos _tokens_ los proporciona la clase `QVD::Config`, no la base de datos. También hay métodos que, por su particularidad, aunque usan la base de datos, no es posible asimilarlos al sistema general (`current_admin_setup`, `get_number_of_acls_in_admin`, etc.).    

==== Métodos con vistas

Por último, existen en `QVD::Admin4` métodos regulares (en el sentido de que toman por argumento un objeto `QVD::Admin4::REST::Request`) pero de comportamiento particular. Los métodos regulares al uso operan sobre objetos reales, correspondientes a tablas concretas de la base de datos: `vm`, `user`, `host` etc. Pero existen otros métodos que operan sobre objetos virtuales: vistas. Estas vistas se han creado como objetos de `DBIx::Class` y son objetos válidos en `QVD::Admin4::Action` y `QVD::Admin4::REST::Model`. Es decir, el sistema los contempla  como objetos igualmente válidos que el resto de objetos de QVD, pero a nivel de base de datos no existen. Esto hace que solo se pueda efectuar sobre ellos operaciones de búsqueda. Sin embargo, no es posible consultar estas vistas con  el método general `select`, pues en `DBIx::Class` la consulta sobre vistas (el filtrado, en realidad) se hace de un modo ligéramente distinto de la consulta sobre tablas reales. 

Por ejemplo, en el sistema se contemplan los siguientes objetos virtuales relativos a acls:

* `Operative_Acls_In_Role`. La vista a la que está asociado este objeto es el producto cartesiano de los acls y los roles del sistema. Para cada par acl/rol, se establece un _flag_ que dice si el rol en cuentión tiene habilidato el acl. El objeto admite filtros que permiten restringir esta información para un rol determinado. Con ello, el método `get_acls_in_roles` permite consultar qué acls están  operativos en un rol determinado y qué acls no lo están.  

* `Operative_Acls_In_Administrator`. La vista a la que está asociado este objeto es el producto cartesiano de los acls y los administradores del sistema. Para cada par acl/administrador, se establece un _flag_ que dice si el administrador en cuentión tiene habilidato el acl. El objeto admite filtros que permiten restringir esta información para un administrador determinado. Con ello, el método `get_acls_in_admins` permite consultar qué acls están  operativos en un administrador determinado y qué acls no lo están.  

Los otros dos objetos virtuales que contempla el sistema son `Operative_Views_In_Tenant` y `Operative_Views_In_Administrator`.

== El sistema de acls

El sistema cuenta con una lista cerrada de acls. Estos acls están asociados en el código a las distintas operaciones que requieran control de permisos. El sistema permite a un administrador efectuar una operación solo si tiene los acls necesarios para ello según el código. En concreto, existen dos niveles de control de permisos en el código:

* Cada acción  soportada por la API puede tener asociada una lista con los acls necesarios para ejecutarse. Esta asociación se establece en la clase `QVD::Admin4::Action`. Cuando la API recibe la petición de ejecutar una acción, crea un objeto `QVD::Admin4::Action` correspondiente a esa acción. Este objeto tiene un método que permite comprobar si un administrador determinado tiene los acls requeridos para ejecutar la acción en cuestión.

* Aunque un administrador pueda ejecutar una acción, quizá no pueda hacer todo aquello que la acción permite. Por ejemplo, un administrador puede tener permisos para ejecutar una acción de actualización de máquinas virtuales. Pero aun así, este administrador puede no tener permisos para actualizar todos los campos de las máquinas virtuales. Quizá haya algún campo en concreto que no pueda actualizar. Por tanto, el sistema contempla un segundo nivel de control de acls: cada uno de los filtros, argumentos, etc. que admite la API puede tener también asociada una lista de acls. Si el administrador no tiene esos acls, no puede usar el elemento en cuestión. La asociación de esos elementos con los acls se hace en la clase `QVD::Admin4::REST::Model`. Un objeto de esta clase permite comprobar si un administrador tiene los acls necesarios para usar cada uno de estos elementos. 

Estas asociaciones de acls a acciones o elementos de una acción siempre siguen la misma estructura. Una acción o elemento lleva asociada una lista de expresiones regulares. Cada expresión regular define un conjunto de acls. Se considera que un administrador tiene acls suficientes para utilizar una acción o elemento si, para cada una de esas expresiones regulares, tiene algún acl que unifique con ella. Esta comprobación se hace, en última instancia, siempre mediante el método `re_is_allowed_to` de la clase `QVD::DB::Result::Administrator`. 

En concreto, cuando la API recibe una _query_ efectúa estas comprobaciones de acls en dos puntos:

* Primero se comprueba que la acción en sí se pueda ejecutar.  En la clase `QVD::Admin4::REST` se crea el objeto `QVD::Admin4::Action` y se ejecuta un método de esta clase que hace la comprobación.

* En segundo lugar, se comprueba que todos los elementos de la _query_ se pueden usar.  En la clase `QVD::Admin4::REST::Request` se cotejan los elementos incluidos en la _query_ con los acls asociados a esos elementos en el modelo `QVD::Admin4::REST::Model` correspondiente. En este caso, las comprobaciones son múltiples y usan diversos métodos (para filtros, argumentos, campos a devolver...).

=== Herencia de acls

Cada administrador puede tener asociados varios roles. Los acls con los que cuenta un administrador son los acls operativos en sus roles. En principio, un administrador tendrá disponible un acl **a** si y solo si **a** es un acl operativo en alguno de sus roles. Las relaciones de asignación entre administradores y roles se establecen en la base de datos en la tabla  `role_administrator_relations` que se corresponde con el objeto `QVD::DB::Result::Role_Administrator_Relation`.

Por su parte, un rol tiene asignados acls. Estos acls son los que, en principio, están operativos en él. Un rol admite tres tipos de asignaciones de acls:

* A un rol se le pueden asignar directamente acls para que estén operativos en él (acls positivos).

* A un rol se le pueden asignar también otros roles. En este caso, el rol en cuestión asume como operativos todos los acls operativos en los roles heredados. 

* A un rol se le puede eliminar un acl heredado si se le asigna un acl negativo. Si un rol hereda el acl **a**, en principio, tendría **a** como acl operativo. Pero si además se le asigna directamente **a** como acl negativo, el rol en cuestión deja de tener **a** como acl operativo.

La asignación de un rol a otro se establece mediante la tabla de la base de datos `role_role_relations`, a la que corresponde la clase `QVD::DB::Result::Role_Role_Relation`. La asignación de acls a roles (acls tanto positivos como negativos) se hace mediante la tabla de la base de datos `acl_role_relations`. La clase correspondiente es `QVD::DB::Result::ACL_Role_Relation`. Esta tabla y estos objetos tienen un flag `positive` que determina si el acl se asigna al rol como acl positivo o negativo.

NOTE: Por tanto, los acls _per se_ no son positivos ni negativos. Lo que puede ser positivo o negativo es la asignación de acl a rol. El acl se puede asignar como acl positivo o como acl negativo.

La API permite asignar y desasignar acls y roles a un rol. Para ello se usan  _nested quieries_ dentro de las acciones `role_update` y `role_create`. Los métodos de `QVD::Admin4` encargados de efectuar estas asignaciones efectúan una serie de operaciones que no resultan del todo transparentes. A saber:

* Cuando se solicita el añadido de un acl **a** a un rol, este no se efectúa si, de hecho, **a** ya estaba operativo en el rol. 

* Cuando se solicita el añadido de un acl **a** a un rol, y en el rol ya existía **a** como negativo, se elimina el **a** negativo. 

* Cuando se solicita la eliminación de un acl **a** y en el rol afectado existía **a** como heredado, se añade una asignación de **a** como acl negativo. 

* Cuando a un rol **R1** que tiene asignado un acl **a** (ya sea como positivo o negativo) se le añade un rol **R2**, se elimina de **R1** el acl **a** si **R2** tiene como acl operativo a **a**. 

* No se permite asignar el rol **R2** a **R1** si **R1** hereda de **R2**. 


Estas operaciones se llevan a cabo a fin de mantener cierta integridad en el sistema de acls de la base de datos, a fin de asegurar que en este sistema se dan ciertas condiciones. El sistema que calcula qué acls operativos hay en un administrador o rol asume que la base de datos es consistente con estas condiciones. Las condiciones que se pretenden mantener son:

* La asignación directa de acls y la asignación de acls por herencia no deben ser redundantes. Si un rol hereda un acl **a**, no puede tener también a **a** asignado directamente.

* Un acl **a** no puede estar asignado a un rol al tiempo como positivo y como negativo. 

* Las relaciones de herencia tienen que tener forma de árbol, no pueden darse bucles donde un rol termine heredando de sí mismo.

En la base de datos, existe una tabla de acls `acls`  y otra de roles `roles`. Y, como se ha visto, existe una tabla `role_role_relations` de relaciones rol/rol y otra `acl_role_relations` de relaciones acl/rol. Además, se ha definido una vista llamada `all_acl_role_relations`, encargada de hacer el trabajo duro. Esta vista toma la información de las tablas anteriores, y con ella calcula, para cada rol, qué acls tiene operativos teniendo en cuenta las relaciones de herencia y la asignación de acls positivos y negativos. A su vez, esta vista es utilizada por los dos _shemas_ de `DBIx::Class` que se usan en todo el sistema para extraer los acls operativos en un administrador o rol:  

* `QVD::DB::Result::Operative_Acls_In_Administrator` y

* `QVD::DB::Result::Operative_Acls_In_Role`.

Estos _schemas_ son, a su vez, vistas, pero no codificadas directamente en la base de datos, sino mediante `DBIx::Class`.

=== Sobrescritura de acls

Como se ha visto, el cálculo de los acls que tiene un administrador depende de los roles que tiene asignados. Sin embargo, ese conjunto de acls operativos para un administrador se puede sobrescribir, se puede modificar. Se ha creado un sistema que permite definir listas de acls que, en un contexto determinado, se le pueden  quitar o añadir a un  administrador o rol, con independencia de los acls que tenga asignados o heredados. En concreto, actualmente, se han definido dos casos de sobrescritura:

* Cuando el administrador no es superadministrador. En estos casos, con independencia de los roles que tenga asignados, se le anulan al administrador todos los acls que permitan gestionar tenants. Esto se debe a que, en estos contextos, el concepto de tenant debe quedar oculto, el sistema debe funcionar como si la diferencia entre tenants no existiera. 

* Cuando el administrador es el administrador de recuperación. Este administrador no tiene asignado rol alguno. Sin embargo, mediante sobrescritura, se le añaden los acls necesarios para recuperar el sistema (relativos a tenants, roles, administradores y configuración). Gracias a ello, se asegura que siempre tenga los acls necesarios para llevar a cabo su cometido.

Mediante este sistema de sobrescritura de acls se puede forzar el particionado de las herramientas de administración de QVD. Eliminando grupos de acls es posible prohibir el acceso y/o visualización de ciertas partes del sistema. Esto es útil para una potencial separación de una versión libre y una versión _commercial_ del sistema. 

Para determinar en cada caso qué acls se deben sobrescribir, se usa `QVD::Admin4::AclsOverwriteList`. El constructor de esta clase toma como parámetro al administrador para el que se quiere efectuar la sobrescritura. Y el objeto resultante informa de los acls que deben sobrescribirse para él, mediante los siguientes  métodos:

* `acls_to_open_re`. Este método devuelve una expresión regular que define el conjunto de acls que deben habilitarse como operativos para el administrador.

* `acls_to_close_re`. Este método devuelve una expresión regular que define el conjunto de acls que deben prohibirse  para el administrador.

* `acls_to_hide_re`. Este método devuelve una expresión regular que define el conjunto de acls que deben, no solo prohibirse, sino también esconderse,  para el administrador. Los acls arrojados por el método anterior son los que el administrador debe ver como no operativos para él. En cambio, los acls de este método son los acls que el administrador no debe ni siquiera ver que existen en el sistema.

Como se ha dicho antes, las clases que permiten en todo el sistema ver qué acls están operativos en un administrador o rol son:


* `QVD::DB::Result::Operative_Acls_In_Administrator` y

* `QVD::DB::Result::Operative_Acls_In_Role`.

Estas clases son _schemas_ de `DBIx::Class`. Son vistas que devuelven los acls operativos en cada administrador o rol. Es en estas vistas donde se efectúa la sobrescritura de acls. Para ello, se les ha colocado a las vistas  _placeholders_ que deben ser instanciados con el resultado de los métodos `acls_to_close_re`, `acls_to_open_re` y `acls_to_hide_re` de un objeto `QVD::Admin4::AclsOverwriteList` correspondiente al administrador para el cual se consultan los acls. Para instanciar estos _placeholders_ se usa el rasgo `bind` de `DBIx::Class`. 

== Vistas configurables

El WAT permite configurar qué elementos de los objetos de QVD se pueden ver. Por ejemplo, un administrador puede configurar si, para las máquinas virtuales, quiere que el WAT le muestre o no el nombre de la máquina, la ip, el usuario al que pertenece o el OSF al que está asociada. Esta configuración puede hacerse a nivel de tenant y de administrador. La configuración a nivel de tenant es la configuración por defecto para los administradores de cada tenant, y se puede sobrescribir después para cada administrador particular. Todo ello se guarda en las tablas `tenant_views_setups` y `administrator_views_setups` de la base de datos. En  cada una de las filas de estas tablas, se establece, para un tenant o administrador, si un elemento concreto debe mostrarse o no en un contexto determinado. En concreto, cada fila consta de estas columnas:

* `qvd_object`. Establece el tipo de objeto de QVD para el cual se quiere mostrar u ocultar un elemento (`vm`, `user`...)
* `field`. Establece el elemento que se quiere mostrar u ocultar. Para `vm`, por ejemplo, `name`, `ip`, `mac`, etc. Este es un campo libre en la base de datos. Los elementos que se guardan aquí son los que puede mostrar el WAT, que no son necesariamente idénticos a los que se contemplan en la API. 
* `visible`. Tiene un valor booleano. Establece si el elemento en cuestión se quiere mostrar (`true`) u ocultar (`false`).
* `device_type`. Establece el tipo de dispositivo (`mobile` o `desktop`) en el que se quiere mostrar u ocultar el elemento.
* `view_type`. Establece el tipo de contexto del WAT en el que se quiere mostrar u ocultar el elemento (`list`, `details` o `filters`).
* `tenant_id` o `administrator_id`. Establecen, respectivamente para `tenant_views_setups` o `administrator_views_setups`, el tenant o administrador para el que se establece la configuración.

En resumen, para configurar en un tenant qué elementos de cada objeto de QVD se muestran en cada contexto del WAT, se introducen en la base de datos registros en la tabla `tenant_views_setups`. Cada uno de esos registros establece, para un determinado elemento de un objeto de QVD, en un contexto determinado, si tiene que mostrarse u ocultarse. Cada administrador de ese tenant puede después sobrescribir esa configuración introduciendo los registros correspondientes en la tabla `administrator_views_setups`. En adelante a este tipo de registros se le llamará _view_. En realidad, por defecto, todos los elementos del WAT son visibles a menos que existan _views_ que pidan lo contrario. Si un elemento determinado no tiene _views_ que hagan referencia a él, será un elemento visible en todo contexto. 

La API, mediante la acción `current_admin_setup`, puede devolver las _views_ apropiadas para el administrador que hace la petición. Estas _views_ devueltas por la API serán, fundamentalmente, el resultado de cruzar las _views_ del tenant con las _views_ del administrador, donde, como se ha dicho, estas segundas sobrescriben a las primeras. Este juego de sobrescritura a partir de las tablas `tenant_views_setups` y `administrator_views_setups` lo hace una vista creada mediante `DBIx::Class`: `Operative_Views_In_Administrator`. Esta es la vista que consulta `current_admin_setup` para devolver las _views_ del administrador en funciones.

=== Las _custom properties_

Las _custom properties_ también son elementos susceptibles de ser mostrados u ocultados en el WAT de acuerdo con el sistema de _views_. El WAT  muestra por defecto todo elemento para el que no reciba _view_ de la API. Sin embargo, se ha considerado oportuno que las _properties_, por defecto, no se muestren. Para conseguir este efecto sin romper la lógica del WAT, es necesario que la API devuelva _views_ que explícitamente marquen cada _property_ como  visible o no visible en todos los contextos existentes, teniendo en cuanta que no visible será el valor por defecto de estas _views_. 

De ello se encarga la vista `Operative_Views_In_Administrator`. Esta vista, además de calcular las _views_ de un administrador a partir del cruce de las _views_ de la base de datos, crea por defecto una serie de _views_ virtuales, no guardadas en la base de datos, pensadas para ocultar las _properties_ en aquellos contextos para los que no existen _views_ reales. El trabajo duro de creación de las _views_ virtuales lo hace una vista de la base de datos a la que se hace referencia desde `Operative_Views_In_Administrator`: `operative_views_in_tenants`. Esta vista lista las _properties_ existentes el la base de datos para cada tipo de objeto de QVD. Por cada una de ellas, se crean _views_ que establecen, para todos los contextos posibles, si se muestran o se ocultan. Para aquellos contextos para los cuales sí existe una _view_ real, se usa esa, para aquellos en los que no, se crea una _view_ virtual con valor `visible` `false`. 

Otra peculiaridad de las _custom properties_ es que pueden ser eliminadas del sistema. Los elementos de un objeto de QVD siempre existen en el sistema (las `vm` siempre tienen `ip` o `mac`). Sin embargo, las _properties_ pueden ser borradas. Cuando una _property_ se elimina del sistema, hay que borrar también las _views_ que pudiera tener asociadas. Para ello, a la acción de borrado de _properties_ de la base de datos se le ha añadido un _trigger_ que lanza una función de borrado de _views_. La función en cuestión se llama `delete_views_for_removed_property`. Los _triggers_ que invocan esta función son:

* `delete_views_for_removed_vm_property`

* `delete_views_for_removed_user_property`

* `delete_views_for_removed_osf_property`

* `delete_views_for_removed_di_property`

* `delete_views_for_removed_host_property`


= El CLI

== Nociones básicas para empezar a usar el CLI

El CLI es una aplicación `CLI::Framework` definida en el archivo `qa`. De momento, solo funciona en modo interactivo. Para arrancar el CLI, se ejecuta el archivo `qa`, pasándole como parámetros el _host_ y el puerto donde escucha la API de administración de QVD contra la que se quiere trabajar.
....
qa --host=localhost --port=3000
....

Con ello, se abre una consola donde se pueden introducir comandos. Para aprender a utilizar la herramienta, ejecútese en esa consola el comando `usage`. 

....
> usage
....

Este comando devuelve la lista de comandos disponibles en el CLI. Además, al ejecutarse `usage` seguido del nombre de un comando (por ejemplo, `login`), se devuelve una explicación más detallada del uso del comando en cuestión.

....

> usage login

....

Para hacer consultas a la API es necesario, en primer lugar, loguearse con una cuenta de administrador. Para ello, se debe ejecutar el comando `login`.

....
> login
....

Al ejecutar este comando, se abre un diálogo en el que se deben introducir las credenciales de la cuenta de administrador con la que se quiere loguearse. Si la API gestiona un QVD en modo monotenant, estas credenciales serán el nombre del administrador y la contraseña; si la API gestiona un QVD en modo multitenant, además, se pedirá el nombre del tenant del administrador.

....
>login
Name: superadmin
Tenant: *
Password:
>
....

Una vez se ha hecho login con éxito, se puede comenzar a hacer consultas a la API. Los comandos que se usan para ello coinciden con los nombres de los objetos de QVD: por ejemplo, el comando `vm` es el encargado de llevar a cabo peticiones a la API relativas a máquinas virtuales, `host` es el encargado de las consultas relativas a los _hosts_, etc. Como se ha dicho arriba, para conocer la lista completa de comandos disponibles, se debe ejecutar el comando `usage`. 

....
> usage
....

Y para  conocer los detalles de uso de cada uno de estos comandos, se ejecuta `usage` seguido del nombre del comando

....
> usage vm
....

Cada comando podrá ir seguido de una secuencia de argumentos. En otras palabras, cualquier petición que se introduzca en la consola del CLI está compuesta por una serie de palabras. La primera de esas palabras es el comando y todas las demás forman la secuencia de argumentos. Por ejemplo, la siguiente es una orden válida en el CLI:  

....
> vm state=running get id, name
....

Esta orden pide que se muestren el `id` y el `name` de todas las máquinas virtuales que estén en estado `running`. Como puede verse, a ojos del usuario, la diferencia entre el comando y los argumentos no es obvia. A sus ojos, la petición es sencillamente una oración que debe ajustarse a una gramática determinada y tiene un significado. El hecho de que la primera palabra sea el comando y el resto los argumentos es más bien una cuestión de diseño interno (si bien el comando `usage` sí hace esta distinción transparente para los usuarios).

== Diseño general del CLI

El CLI se ha creado a partir del _framework_ `CLI::Framework`. El ejecutable que permite poner en marcha la herramienta es el archivo `qa`, pero la clase que define propiamente el CLI es `QVD::Admin4::CLI`, una subclase de `CLI::Framework`. A su vez, los comandos  del CLI son subtipos de  `CLI::Framework::Command`. En definitiva, a todos los efectos, el CLI es una aplicación de tipo `CLI::Framework`, sigue su lógica y utiliza sus recursos. Como en toda aplicación `CLI::Framework`, en la clase que define el CLI (`QVD::Admin4::CLI`) se registran los comandos disponibles. Y cada uno de estos comandos se ha definido, además, como una clase independiente: `QVD::Admin4::CLI::Command::VM` para el comando `vm`, `QVD::Admin4::CLI::Command::Host` para el comando `host`, etc.

La mayoría de los comandos del CLI (aquellos que se corresponden con objetos de QVD) funcionan de forma prácticamente idéntica. De hecho, todos ellos se han definido como subclases de una clase común `QVD::Admin4::CLI::Command` (que a su vez es subclase de `CLI::Framework::Command`). Esta clase común es la que guarda la lógica común que determina cómo se procesa un comando del CLI. Esta lógica es, básicamente, la siguiente: el comando inroducido en el CLI junto a los argumentos que lo siguen forman una oración; un _parser_ analiza esta oración y devuelve como _output_ un JSON susceptible de ser enviado como petición a la API;  se envía dicha petición a la API; y cuando esta responde, se saca la respuesta por consola en forma de tabla. En resumen:

* Un _parser_ analiza la petición escrita en la consola del CLI.

* El resultado del análisis del _parser_ se manda como petición a la API.

* La respuesta de la API se convierte en una tabla y se saca por consola.

Por tanto, para explicar con más detalle el diseño del CLI, será necesario explicar el funcionamiento del _parser_ encargado de procesar las peticiones, y será necesario explicar también la clase `QVD::Admin4::CLI::Command`, encargada de articular los tres pasos necesarios para ejecutar cada petición. 

== El _parser_ de las peticiones del CLI

El proceso de _parsing_ recibe como _input_ una oración en forma de _string_. Esta _string_ tiene que convertirse en una lista de palabras (_tokens_). Al proceso que divide la _string_ original y la convierte en una lista de palabras o _tokens_ se le ha llamado tokenización. El objeto encargado de la tokenización está definido en la clase `QVD::Admin4::CLI::Tokenizer`. Es un objeto muy simple que efectúa la división de la _string_ conforme a una sencilla gramática de expresiones regulares; y devuelve la lista correspondiente de palabras (_tokens_).

Una vez el tokenizador ha creado la lista de _tokens_, esta se le pasa como _input_ al objeto encargado del análisis sintáctico. Este es un objeto de tipo `QVD::Admin4::CLI::Parser` que toma una lista de _tokens_ y crea con ellos una estructura arbórea. El proceso de análisis sintáctico que lleva a cabo este objeto consiste, básicamente, en tomar constituyentes y unirlos para crear otros constituyentes mayores. En un primer momento, estos constituyentes son los _tokens_ que ha recibido el objeto como _input_. 

Este proceso de análisis es un proceso iterativo. Cada iteración del proceso opera sobre un conjunto de constituyentes **C**, y efectúa los siguientes pasos:

* Los  constituyentes de **C** se intentan combinar para crear nuevos constituyentes.
* A continuación, estos constituyentes nuevos se añaden a **C**.
* Con la nueva versión ampliada de **C**, se lanza la siguiente iteración del proceso de análisis. 

Como ya se ha dicho, en la primera iteración del proceso, **C** está formado por los _tokens_ que forman el _input_ del análisis. Y la última iteración será aquella que no consiga crear ningún constituyente nuevo a partir de los constituyentes de **C**. 

Pero este proceso de unión de constituyentes está regulado: no es posible unir dos sonstituyentes cualesquiera para crear un nuevo constituyente. Para que dos o más constituyentes se puedan unir, se tienen que dar dos condiciones:

* Los constituyentes que se unen tienen que ser contiguos. 

* Debe existir en la gramática que usa el _parser_ una regla que permita unir constituyentes del tipo en cuestión. 

Efectivamente, el _parser_ analiza siempre de acuerdo con una gramática. Una versión muy simpista de este tipo de gramática  pudiera tener la lógica representada a continuación: 

....
X => get + name
X' => vm + X
....  

Esta sencilla gramática establecería que se puede crear un constituyente `X` uniendo los constituyentes,`get` y `name`; y  que se puede crear un constituyente `X'` uniendo los constituyentes `vm` y `X`. Así pues, estas reglas permitirían analizar la oración `vm get name` (que pide el nombre de todas las máquinas virtuales). A esta oración, le  corresponde la lista  de _tokens_ `('vm', 'get', 'name')`. De acuerdo con las reglas de la gramática, esos _tokens_ podrían unirse secuencialmente en dos pasos:  `get` y `name` se unen y forman `X`; y a continuación, `vm` y `X` se unen para crear `X'`.

Además, las reglas de la gramática obligan a que los constituyentes que se unen sean contiguos y aparezcan en la cadena original de _tokens_ en el orden que expresa la regla. 
Los _tokens_ iniciales del análisis, y los constituyentes mayores que se hayan podido crear a partir de ellos, tienen siempre dos índices, llámense _from_ y _to_, que indican la posición que ocupan en la lista original de _tokens_. Por ejemplo, en `vm get name`, el _token_ `vm` abarca la posición 0 de la lista de _tokens_,  `get` la posición 1 y `name` la posición 2. Por tanto, sus índices _from_ y _to_ son, respectivamente, _from_ 0, _to_ 0; _from_ 1, _to_ 1; y _from_ 2, _to_ 2. De forma consecuente, el constituyente `X` tendría los índices  _from_ 1, _to_ 2; y el constituyente `X'` tendrá los índices _from_ 0, _to_ 2. En definitiva, para que dos constituyentes se puedan unir, el índice _from_ de cada constituyente de una regla tiene que ser igual al índice _to_  más 1 del siguiente constituyente de la regla.

Este proceso de análisis puede tener éxito o no. Puede llegarse a encontrar un análisis adecuado para una oración, o no. En caso de que el _parser_ no consiga dar un análisis a la oración, se concluye que tal oración es agramatical; es decir, que, conforme a la gramática, la oración en cuestión no es correcta. Pero para determinar si una oración es o no gramatical, en la gramática se tiene que incluir el concepto de axioma. El axioma de la gramática es el tipo de constituyente que representa  a la oración completa. En el caso de la gramática anterior, el axioma debería ser `X'`. En definitiva, el objetivo de un proceso de análisis es crear constituyentes mediante la unión de otros constituyentes hasta crear uno o varios axiomas. Se considera que el _parsing_ ha encontrado un análisis satisfactorio, si se ha creado un constituyente catalogado como axioma que cubra toda la extensión de la lista original de _tokens_. En caso contrario, se concluye que la oración es agramatical.

En resumen, un _parser_ (objeto de tipo `QVD::Admin4::CLI::Parser`) toma una lista ordenada de _tokens_. Estos _tokens_ los convierte en constituyentes atómicos del proceso de análisis. A partir de ahí, de forma iterativa, une constituyentes para crear nuevos constituyentes. Para que se puedan unir dos o más constituyentes, es necesario que estos sean contiguos y que la unión esté legitimada por alguna regla de la gramática. Una vez el proceso de _parsing_ ya no es capaz de efectuar nuevas uniones, el análisis termina. En ese momento, se buscan todos los constituyentes creados que cumplan dos condiciones: que sean de un tipo definido como axioma y  que cubran toda la lista original de _tokens_. La lista de constituyentes que cumple esos dos requisitos se devuelve como la lista de análisis posibles para la oración analizada. Si esa lista está vacía, la oración puede catalogarse como agramatical; y si contiene más de un análisis, la oración será ambigua. En el CLI, en estos casos, se devolverá un mensaje de error. El caso deseable en el CLI es que la lista cuente con un único elemento, de modo que sea gramatical no ambigua y se pueda usar para efectuar una petición concreta a la API. 

Para llevar a cabo todo este proceso, el objeto `QVD::Admin4::CLI::Parser` hace uso de otra serie de objetos auxiliares:

* La clase `QVD::Admin4::CLI::Grammar` define la gramática conforme a la cual se analiza.

* La clase `QVD::Admin4::CLI::Parser::Edge` define, _grosso modo_, a los constituyentes que se van creando. 

* La clase `QVD::Admin4::CLI::Parser::Chart` define el repositorio de constituyentes creados por el análisis. En adelante, se le identificará como el _chart_. 

* La clase `QVD::Admin4::CLI::Parser::Agenda` define la lista de constituyentes que, en una iteración concreta, se van a intentar combinar con los constituyentes del _chart_. En adelante, se identificará a esta lista como _agenda_.

La explicación del algoritmo de análisis hecha hasta ahora es una simplificación. El proceso de análisis es, como se ha dicho, iterativo. Pero cada iteración no consiste simplemente en combinar entre sí todos los constituyentes de un supuesto repositorio **C**. En realidad, el _parser_ cuenta con dos repositorios distintos de constituyentes: el _chart_ y la _agenda_. En cada iteración número _n_, el _chart_ contiene todos los constituyentes que se han ido creando durante las iteraciones anteriores a la iteración inmediatamente anterior (las número  _n_ - 2 y anteriores). Y la _agenda_ contiene los constituyentes que se han creado en la iteración inmediatamente anterior (la número _n_ - 1). Así pues, en cada iteración número _n_, se intenta combinar cada uno de los constituyentes de la _agenda_ con los constituyentes del _chart_. Los constituyentes resultantes de esas combinaciones serán los que formen la _agenda_ de la siguiente iteración (la número _n_ + 1). Y los constituyentes que en la actual iteración (la número _n_) estaban en la _agenda_ pasan al _chart_. El final del proceso se alcanza cuando en una iteración la _agenda_ que se crea para la siguiente iteración es una lista vacía. En cuanto al comienzo del proceso, en la primera iteración (_n_ = 1), la _agenda_ está formada por la lista de _tokens_ que se le pasan al _parser_ como _input_; y el _chart_ está vacío (no ha habido iteraciones anteriores que hayan creado constituyentes). 

Pero, tal como se ha explicado el algoritmo, el resultado de esta primera iteración sería necesariamente una _agenda_ vacía, con lo cual acabaría todo el análisis de forma trivial. Como el _chart_ está vacío, la combinación de constituyentes de la _agenda_ con los del _chart_ dará lugar necesariamente a una agenda vacía para la siguiente iteración. En realidad, en cada iteración, no solo se combinan los constituyentes de la _agenda_ y el _chart_. También se efectúa una segunda operación crucial que crea constituyentes: la expansión de constituyentes.

La expansión de constituyentes consiste en lo siguiente. Cada regla de la gramática legitima la creación de un constituyente de tipo *X*  mediante la unión de una serie de constituyentes *x1*, *x2*, etc. Pues bien, si un constituyente de la _agenda_ es del tipo *x1*, y existe en la gramática una regla que permite crear un *X* a partir de una serie de constituyentes tales que el primero es de tipo *x1*; en tal caso, el _parser_ crea el nuevo constituyente *X*. Pero téngase en cuenta que, habitualmente, la regla en cuestión establecerá que, para crear *X*, además de *x1*, hace falta al menos otro constituyente *x2*. Así pues, este nuevo constituyente creado, más que un constituyente real, es una hipótesis de constituyente. Para que el constituyente llegara a ser legítimo, sería necesario que, en fases posteriores del análisis, se encontrara un *x2* que permitiese completar el constituyente. Si esto no ocurriera, esta hipótesis de constituyente sería errónea. Por tanto, en el proceso de análisis se contemplan, no uno sino dos tipos de unidades de análisis:

* Los _edges_ inactivos. Son _grosso modo_ los constituyentes reales, completos, que se han formado durante el análisis.  

* Los _edges_ activos. Son hipótesis de constituyente a las que les falta alguno de los elementos necesarios para formar el constituyente real.

Por tanto, a partir de ahora, se hablará de _edges_ (activos o inactivos) y no de constituyentes. Así pues, en cada iteración, se dan dos procesos:

* Combinación de _edges_. Los _edges_ inactivos de la agenda se intentan combinar con los _edges_ activos del _chart_; y los _edges_ activos de la agenda se intentan combinar con los _edges_ inactivos del _chart_. En ambos casos, se intentan combinar un _edge_ activo con un _edge_ inactivo. El _edge_ activo se caracteriza por tener una lista ordenada de uno o más elementos (*x2*, *x3*...) pendientes de saturar. Si el _edge_ inactivo representa al primer elemento pendiente de saturar en el _edge_ activo (*x2*), en tal caso, se crea un nuevo _edge_. Este nuevo _edge_ será como el _edge_ inactivo original, pero con *x2* saturado. Su índice _from_ será el índice _from_ del _edge_ activo, y su índice _to_ será el _to_ del inactivo. Este nuevo _edge_ será activo o inactivo en función de que le quede aún o no algún elemento por saturar.

* Expansión de _edges_. Los _edges_ inactivos de la _agenda_, además de combinarse, se pueden expandir. Para cada _edge_ inactivo *x1* de la agenda, se crea un nuevo _edge_ *X* por cada regla de la gramática que permita generar *X* a partir de una lista de constituyentes de la cual el primer elemento es *x1*. Este nuevo _edge_ tendrá los índices _from_ y _to_ del _edge_ inactivo a partir del que se forma. Y será activo o inactivo en función de que la lista de constituyentes de  la regla en cuestión tenga algún elemento más (*x2*...) detrás de *x1*.

== La clase `QVD::Admin4::CLI::Command`

